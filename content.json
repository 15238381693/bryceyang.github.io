{"pages":[{"title":"About me","text":"北邮研三在读，校招中的一只咸鱼，目前技术栈主要为Python后端，秋招结束之后打算再点亮一些go语言技能树。凑篇幅，贴一下我很喜欢的一句话：“For man is man and master of his fate.”。 祝我爱的人都平安喜乐，祝爱我的人都喜乐平安。","link":"/about/index.html"}],"posts":[{"title":"Problems I encountered when I use Arch Linux","text":"使用了Arch快半年了，这个文章实在是写晚了。。 error: failed to commit transaction (conflicting files)问题描述：这个问题已经碰到了几次，原因暂未知。 1234error: failed to commit transaction (conflicting files)python-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/PKG-INFO exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/SOURCES.txt exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/dependency_links.txt exists in filesystem 解决方法：首先，检测一下冲突文件有没有包在使用1pacman -Qo /path/to/file 结果一般就是没有包在使用。。所以下面就rm掉所有引起冲突的文件就行了，问题解决。最近碰见了这个问题好几次，但是出现原因暂未知。。太烦了。 screen tearing问题描述：我不知道这个问题应不应该叫做窗口撕裂：在上下滚动内容的时候，滚动方向最下面的内容会出现重影，显得好像屏幕刷新有延迟。 解决方法： 1sudo vim /etc/X11/xorg.conf.d/20-intel.conf 然后添加如下内容： 123456Section &quot;Device&quot; Identifier &quot;Intel Graphics&quot; Driver &quot;intel&quot; Option &quot;TearFree&quot; &quot;true&quot; Option &quot;AccelMethod&quot; &quot;uxa&quot;EndSection 默认的AccelMethod的值为sna，在我这里使用sna会出现滚动延迟的情况，但是使用uxa就没有这种现象。但是更改了这个值之后发现了一个新问题就是笔记本不合盖子屏幕自动关闭之后不能唤醒，只有切到tty之后再切回来才行。待解决。 signature from xxx is marginal trust问题描述： error: archlinuxcn-keyring: signature from “Jiachen Yang \\&lt;farseerfc@gmail.com /&gt;” is marginal trust:: File /var/cache/pacman/pkg/archlinuxcn-keyring-20170522-1-any.pkg.tar.xz is corrupted (invalid or corrupted package (PGP signature)). 解决办法： sudo pacman-key --refresh-keys 代码运行结果就是新导入了很多PGP signature, 然后问题解决。 解决方法二 1234sudo rm -R /etc/pacman.d/gnupg/pacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcn 可以看出这也是走的更新key的路数。 但是出现这种问题执行pacman -S archlinux-keyring重装archlinux-keyring是没有用的。 还有一种说法是系统时间不正确 不知道这个系统时间是指哪个时间。 /opt sysmlink file conflicts问题描述：由于在安装Arch系统时，/home分区是独立于/root分区的，而yaourt安装的大型软件都是会安装到/opt下面，导致系统分区会被很快用光。所以我的解决方法是在/home分区下新建opt分区，然后建立软链接： ln -s /home/opt /opt 但是这样做之后会导致在yaourt安装软件是出现/opt already exists的file conflicts错误。 官方解释如下： Directory Symlink Handling: Example time! Arch Linux has a /lib -&gt; /usr/lib symlink. Previously, if pacman was installing a package and it found files in /lib, it would follow the symlink and install it in /usr/lib. However the filelist for that package still recorded the file in /lib. This caused heaps of difficulty in conflict resolving – primarily the need to resolve every path of all package files to look for conflicts. That was a stupid idea! So now if pacman sees a /lib directory in a package, it will detect a conflict with the symlink on the filesystem. If you were using this feature to install files elsewhere, you probably need to look into what a bind mount is! Note that this change requires us to correct the local package file list for any package installed using this mis-feature, so we bumped the database version. Upgrade using pacman-db-upgrade. Thanks to Andrew! 解决方法： 在/etc/fstab里加入如下内容： 12# solve the /opt sysbolink file conficts errors/home/opt /opt none bind problems solved, splendid! wine下TIM中文界面部分乱码问题描述： 已经通过winetricks corefonts cjkfonts安装了字体，但是qq登录界面以及消息预览界面的中文都是方块。 解决方法： 123456789101112131415161718vim .wine/system.reg搜索： LogPixels找到的行应该是：[System\\\\CurrentControlSet\\\\Hardware Profiles\\\\Current\\\\Software\\\\Fonts]将其中的：“LogPixels”=dword:00000060改为：“LogPixels”=dword:00000070搜索： FontSubstitutes找到的行应该是：[Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\FontSubstitutes]将其中的：“MS Shell Dlg”=”Tahoma”“MS Shell Dlg 2″=”Tahoma”改为：“MS Shell Dlg”=”SimSun”“MS Shell Dlg 2″=”SimSun” SimSun代表windows下的simsun.ttc字体，这里提供下载：下载simsun.ttc xfce4下开机时某些非自启应用会自动运行问题描述：已经关闭了auto save sessions，但是在登录之后某些应用仍然会自动启动，具体表现为某次关机前系统的工作状态。 解决方法： 1rm -r .cache/sessions/* All clear!!!","link":"/2017/05/17/Problems-I-encountered-when-I-use-Arch-Linux/"},{"title":"正则表达式入","text":"这是主要参考文献：正则表达式入门，本文只是做了修改以便于自己记忆。 1. 元字符 metacharater \\b 代表着单词的开头或者结尾，也就是单词的分界处； . 匹配除了换行符以外的任意字符； \\d 匹配一位数字； \\s 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等； \\w 匹配字母或数字或下划线或者汉字等； ^ 匹配字符串的开始； $ 匹配字符串的结束； 字符转义仍然是使用\\ 2. 限定 + 指定前面的内容可以连续重复1次或者更多次； * 指定前面的内容可以连续重复任意次（包括0次)； ? 重复零次或者一次； {n} 重复n次； {n,1} 重复n次或者更多次； {n,m} 重复n次到m次； 3. 字符类可以利用方括号来匹配所需字符，[acb]代表可以匹配abc其中的一个，所以[]只用来匹配没有元字符对应的字符集中的单个字符 比如[0-9],就跟\\d是完全一致的，也就是匹配单个数字 4.分支条件 正则表达式分支条件示例：\\d{5}-\\d{4}|\\d{5} 这个例子含有一个小的tricky的地方，就是它说明了一个问题：用分支条件时，要注意各个条件的顺序。如果把这个表达式改为\\d{5}|\\d{5}-\\d{4}，那么就只会匹配五位的邮编以及9位邮编的前5位。 原因是匹配分支条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会再管其它条件。 5. 分组上面所说的都是重复单个字符的方法，如果想要重复多个字符可以用小括号来指定子表达式（也叫作分组），这也是当我们需要（字符本身时需要对其进行转义的原因。 (\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 6.反义 代码语法 说明 \\W 匹配任意不是字母、数字、下划线、汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 7.后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容）可以在表达式或者其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组组号为1，第二个为2，以此类推。 分组0对应整个正则表达式； 实际上组号分配过程是要从左到右扫描两遍：第一遍只给未命名组分配，第二遍只给命名组分配–因此所有的命名组的组号都大于未命名组的组号； 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权。 \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 常用分组语法： 待补充 8. 零宽断言","link":"/2017/05/20/beginning-regular/"},{"title":"Arch linux安装以及后续配置过程整理","text":"整理一下这个教程便于以后可以无脑重装Arch Linux，美滋滋啊。 准备以及分区1.准备 准备内容 USB stick Arch Linux ISO image Arch Linux Download Addr 创建启动盘 On windows: Rufus On linux: sudo dd if=/path_to_arch_.iso of=/dev/sdx sdx代表你的U盘，可以用lsblk命令查看得到。 接下来就是设置bios启动方式，教程基于UEFI+GPT的引导启动方式。请自行设置。 设置USB为下一次的引导路径，然后重启之后我们就能进入Arch安装环境了 查看EFI mode是否开启 efivar -l 如果有输出，就说明已经开启。 2.分区lsblk 12345gdisk /dev/sdx (x representing your drive)x # into expert modez # clear the disky # confirmy # confirm 创建分区 分区设定如下： sda sda1(boot partition) sda2(our swap partition) sda3(our root partition) sda4(our home partition) 使用cgdisk分区： cgdisk /dev/sdx 12345[New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 1024MiB -&gt;press EnterHex Code: EF00 press EnterEnter new partition name: boot -&gt;press Enter boot分区的Hex Code为EF00，千万不要弄错，有些资料会说是EF02，实测EF00才有效。 arch wiki上说boot分区分配200-300mb就行了，但是为了以后的双系统等未知需求，分配1Gb。 12345[New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 8GiB -&gt;press EnterHex Code: 8200 -&gt;press EnterEnter new partition name: swap -&gt;press Enter swap分区的Hex Code是8200。 swap分区的开启与否以及大小设置一直是争论焦点。这里贴出参考： askubuntu_swap serverfault_swap 下面建立root分区和home分区。两者Hex code都是默认的8300。如果不独立设置home分区，就可以直接把剩余空间都设置为root分区。如果设置独立的home分区，可以分配30G左右给root分区，剩余空间分配给home分区。分区全部建立完毕之后，我们就要设置分区格式了。 12345mkfs.fat -F32 /dev/sda1mkswap /dev/sda2swapon /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4 安装Arch 以及配置启动挂载分区12345mount /dev/sda3 /mntmkdir /mnt/bootmkdir /mnt/homemount /dev/sda1 /mnt/bootmount /dev/sda4 /mnt/home 设置mirrorlist 学校有ipv6的学生可以用清华的源，ipv6直连，美滋滋。 nano /etc/pacman.d/mirrorlist 在最前面加上 12# TsinghuaServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 安装系统1pacstrap -i /mnt base base-devel 将分区结构写入新系统： 1genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab 可以通过nano /mnt/etc/fstab查看是否创建成功 接下来就可以切换到我们新安装的系统了 arch-chroot /mnt 配置系统设置语言个人喜欢用英文，因为跟整体linux环境比较统一。 nano /etc/locale.gen 然后取消掉en_US.UTF-8和zh_CN.UTF-8前面的注释。 使其生效： locale-gen 接下来设置语言： 12echo LANG=en_US.UTF-8 &gt; /etc/locale.confexport LANG=en_US.UTF-8 设置时区：ln -s /usr/share/zoneinfo/Asia/Shanghai &gt; /etc/localtime 请自觉使用tab补全以免出错。 设置硬件时钟： hwclock --systohc --utc 设置主机名：echo hostname &gt; /etc/hostname 对pacman.conf的细化修改编辑pacman.conf取消multilib前面的注释： 这个是为了在64位机器上运行32位程序 12[multilib]Include = /etc/pacman.d/mirrorlist 然后强烈推荐添加的yaourt 123[archlinuxfr]SigLevel = NeverServer = http://repo.archlinux.fr/$arch 一定要注意大小写。 必须添加的archlinuxcn源，里面有很多中国特色软件，比如网易云、有道词典之类的，同样推荐清华源。 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后安装archlinuxcn-keyring包以导入GPG key。 这个时候就可以保存pacman.conf文件了。 账户相关设置root账户的密码： passwd 添加日常用户： useradd -m -g users -G wheel,storage,power -s /bin/bash yourusername 设置密码： passwd yourusername 设置sudoers： EDITOR=nano visudo 然后取消注释： %wheel ALL=(ALL) ALL 设置使用sudo命令的用户必须输入root密码： Defaults rootpw Done! 安装补全命令： pacman -S bash-completion 安装引导确保EFI变量被挂载 mount -t efivarfs efivarfs /sys/firmware/efi/efivars 使用Gummiboot作为启动管理，Gummiboot已经整合到了bootctl/system-boot里，所以安装方式为： bootctl install 下面，把/root分区的PARTUUID加入到启动设置里： blkid -s PARTUUID -o value /dev/sdxY x代表设备代号，本次为a，Y是/root partition的排号，本次为3. 然后添加gummiboot manager配置文件： 123456nano /boot/loader/entries/arch.conf# 下面是内容：title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=PARTUUID=上个命令得到的 rw 保存并退出 添加intel支持： pacman -S intel-ucode 然后写入到启动管理设置里： 123nano /boot/loader/entries/arch.confinitrd /intel-ucode.imginitrd /initramfs-linux.img 这个时候基本的操作已经完成了，我们可以重启试试了。 123exitumount -R /mntreboot 安装xfce4桌面环境1234567sudo pacman -S mesasudo pacman -S xorg-server xorg-server-common xorg-xinitsudo pacman -S xfce4sudo pacman -S xfce4-goodiessudo pacman -S sddmsudo systemctl enable sddm.servicereboot 安装完成，可以使用了。美滋滋。 安装Tex Live123yaourt -S texlive-mostyaourt -S texlive-langchineseyaourt -S texstudio 安装完成之后使用tex --version测试： 12345678910-&lt;%&gt;- tex --versionTeX 3.14159265 (TeX Live 2016/Arch Linux)kpathsea version 6.2.2Copyright 2016 D.E. Knuth.There is NO warranty. Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX source.Primary author of TeX: D.E. Knuth. 使用texstudio编写测试文件： 新建test.tex,内容如下： 123456789101112131415\\documentclass{article}\\usepackage{graphicx}\\begin{document}\\begin{figure} \\includegraphics[width=\\linewidth]{favicon.jpg} \\caption{A boat.} \\label{fig:boat1}\\end{figure}Figure \\ref{fig:boat1} shows a boat.\\end{document} Build &amp; View查看运行结果，正常结果如下：","link":"/2017/05/24/Arch-Linux-installation-tutorial/"},{"title":"git和jupyter使用小技巧","text":"git1. git push 免密码通用情况 1.使用文件创建用户名和密码 文件创建在用户主目录下： 123touch .git-credentialsvim .git-credentialshttps://{username}:{password}@github.com 记得在真正输入的时候是没有大括号的。 2.添加git config内容 git config --global credential.helper store 执行此命令后，用户主目录下的.gitconfig文件会多了一项：[credential] helper = store 重新git push就不需要用户名密码了。 使用ssh协议首先生成密钥对： 1ssh-keygen -t rsa -C &quot;youremail&quot; 接下来按照提示操作，默认可以一路往下。 然后将生成的位于~/.ssh/的id_rsa.pub的内容复制到你github setting里的ssh key中。 复制之后，如果你还没有克隆你的仓库，那你直接使用ssh协议用法：`git@github.com:yourusername/yourrepositoryname`克隆就行了。 如果已经使用https协议克隆了，那么按照如下方法更改协议：git remote set-url origin git@github.com:yourusername/yourrepositoryname.git Done! 2. git add 使用tab键自动补全的中文文件名乱码文件名乱码如下所示： 解决方法为： git config --global core.quotepath false 效果如下： 可以看出中文已经正确显示了。 3. git迁移仓库到另外一个仓库12# 仅保留历史提交信息git clone --bare yourrepository 然后在你的其他服务，比如gogs新建一个仓库，然后进入你上步克隆出的仓库中，执行：1git push --mirror yourNewRepository 然后你就可以删除原来的仓库，然后git clone新仓库就行了。 jupyter1. jupyter notebook 创建密码产生jupyter notebook的配置文件： 1jupyter notebook --generate-config 生成的配置文件位置为：~/.jupyter/jupyter_notebook_config.py 打开jupyter，新建一个notebook，创建密码以及生成密码的sha1密钥，所需代码如下： 12from notebook.auth import passwdpasswd() 输入一遍你想设置的密码，然后再输入一遍确认，记录下生成的sha1密钥值。形式如：‘sha1:xxxxxxx’ 然后将这段值按如下格式粘贴到配置文件中对应的c.NotebookApp.password = u'sha1:xxxx'位置上，如果你不想寻找文件中的这个位置，你也可以在文件末尾新建一个。 重启jupyter，密码生效。","link":"/2017/05/25/Tips/"},{"title":"Ubuntu以及Arch Linux更换清华源","text":"UbuntuUbuntu清华源更换网址 这个地址里同样有其他Linux发行版的源使用帮助信息。 更换步骤 1.在上述网址选择ubuntu版本，生成对应的源地址； 2.备份原始文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 3.编辑源文件 sudo vim /etc/apt/sources.list 将sources.list中内容注释或者删除掉，然后将第一步中生成的源地址粘贴进去； 4.然后更新软件包缓存sudo apt update Arch Linux编辑­/etc/pacman.d/mirrorlist,在文件最顶端添加： Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后更新软件包缓存sudo pacman -Syy","link":"/2017/06/23/change-software-sources-of-arch-and-ubuntu/"},{"title":"Ubuntu常用软件","text":"习惯了Arch的yaourt之后再使用ubuntu ppa就有一种就怕货比货的感觉。 收集一下常用的ubuntu软件安装，便于下次无脑重装。 Albert这款软件是必装的了，一个很好用的Launcher。官方介绍如下： Access everything with virtually zero effort. Run applications, open files or their paths,open bookmarks in your browser, search the web, calculate things and a lot more … Ubuntu-PPA(hotice/webupd8) 123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install albert chrome1.将下载源添加到系统源： sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ 2.导入google软件公钥： wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - 3.更新源然后安装： 12sudo apt updatesudo apt install google-chrome-stable","link":"/2017/06/24/daily-software-of-ubuntu/"},{"title":"Ubuntu tips","text":"1. 更换pip源为阿里云的镜像源官方帮助教程 编辑pip配置文件: vim ~/.pip/pip.conf 然后写入如下内容： 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com 如果发现没有对应文件夹以及配置文件，请直接自行创建。 2. Ubuntu将默认的python版本换为python3.XUbuntu 16.04自带了python2.7和python3.5，且默认版本为python2.7，最近一直使用python3.×版本所以需讲python默认版本修改为3.5。 可以使用ls /usr/bin | grep python来查看目前存在的python版本 然后设置软链接，讲python3.5设为默认： sudo ln -s /usr/bin/python3.5 /usr/local/bin/python 此时python3.5已经成为默认。 然后此时需要注意的就是，如果以后主要在3.×的环境下工作，请安装对应3.×的包。 12sudo apt install python3-pippip3 install package_name 3. Ubuntu设置ssh密钥登录并关闭ssh密码登录连网的机器安全第一，所以ssh的安全性就是重中之重了。使用ssh密钥登录，并关闭密码认证是有效的防止机器被入侵的方式。 Ubuntu设置ssh密钥登录的步骤如下： 1.首先安装ssh sudo apt install ssh 2.制作密钥对 ssh-keygen 你应该会看到如下的内容： 1234Generating public/private rsa key pair.Enter file in which to save the key(/home/user/.ssh/id_rsa):...... 3.将公钥写入到对应文件里 12cd ~/.sshcat id_rsa.pug &gt;&gt; authorized_keys 然后确保对应文件的权限是正确的: 12chmod 600 authorized_keyschmod 700 ~/.ssh 4.设置ssh配置文件，打开密钥登录并关闭密码登录 编辑/etc/ssh/sshd_config文件，确定如下设置： 12RSAAuthentication yesPubkeyAuthentication yes 当你确定可以使用密钥方式登录成功之后，再禁用密码登录： PasswordAuthentication no 记得如果这些修改项是被注释掉的，记得把注释取消。 5.重启ssh服务 service sshd restart 6.关于putty使用id_rsa的一点儿说明 putty是不能直接使用id_rsa私钥的，需要使用puttygen转换。 首先从服务器下载id_rsa到本地，然后使用puttygen载入，然后选择Save private key讲私钥保存为putty能用的.ppk文件。然后就跟一般的putty使用key登录一样了。","link":"/2017/06/25/ubuntu-tips/"},{"title":"latex tips","text":"1.\\min的两种表示方法 12\\min\\limits_{a}\\min\\nolimits{a} 对应的显示效果如下： 2. latex插入python代码 在latex里插入python代码需要使用包pythonhighlight,如果你使用tex live 2017的话，这个包已经安装了，可以直接使用； 如果你安装的latex版本默认没有这个包，你可以去这个地址下载pythonhighlight.sty文件，然后放到自己的.tex文件目录下，就可以使用了。 使用过程如下： 先在latex导言区输入： 12\\usepackage{graphicx}\\usepackage{pythonhighlight} 插入python代码有两种方式： 然后在需要插入代码的地方： 12345\\inputpython{python_filename.py}{begin line number}{end line number}%或者使用这种方式\\begin{python}contents\\end{python}","link":"/2017/06/26/Latex-tips/"},{"title":"Ubuntu 16.04安装jekyll","text":"一直以来在github写博客习惯于直接git提交后在github pages看效果，这样来回修改就会繁琐的commit、push,所以还是搭建jekyll本地环境预览吧。 1.安装ruby 1sudo apt install ruby-full ruby-bundler 这里如果下意识的使用sudo apt install ruby安装ruby会导致下一步安装jekyll的时候出现如下错误： 2.安装jekyll 1sudo gem install jekyll 3.检测jekyll是否安装成功 1234jekyll -vjekyll new new-sitecd new-sitejekyll serve 在浏览器里打开http://localhost:4000可以看到预览效果。","link":"/2017/06/26/install-jekyll-on-ubuntu/"},{"title":"使用vim编写fortran代码的一些相关设置","text":"最近开始干活了，实验室主流语言是fortran，一种很褒贬不一的语言。由于是Arch linux用户，所以需要对linux编写编译fortran代码做一些准备工作。 1.首先，在linux下fortran编译器还是很多的，有很方便就能安装的gfortran，还有诸如intel或者PGI这些公司提供的编译器。intel家的编译器对学生免费，所以自然就成了首选。详情请去这个链接查看。 2.安装intel parallel studio的过程是图形化的，一般不会出现什么问题。安装之后设置一下路径就能使用ifort命令编译fortran文件了。 3.在linux编写fortran代码我还是按照习惯选择了vim，然后我们需要在.vimrc中加入如下设置项： 1234567891011121314\"语法高亮syntax enablesyntax on\"fortran语言制表符设置let fortran_have_tabs=1\"设置制表符宽度set tabstop=4\"解决中文注释乱码set fileencodings=urf-8,gb18030,utf-16,big5\"设置代码折叠let fortran_fold=1set foldmethod=syntax\"设置默认文件打开后所有折叠自动展开set foldlevelstart=99 vim有关代码折叠的命令如下： 1234zc：折叠代码zo：展开代码zC：折叠所有代码zO：展开所有代码 最后效果图： 这里vim的配色主题为molokai。","link":"/2017/07/01/how-to-wirte-fortran-with-vim/"},{"title":"vim配置","text":"1. vim基本设置所需依赖: Vundle powerline font vim配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111\"-----------------vim基本设置--------------------------\"\"关闭vi的一致性模式 避免以前版本的一些Bug和局限set nocompatible\"配置backspace键工作方式set backspace=indent,eol,start\"显示行号set number\"设置在编辑过程中右下角显示光标的行列信息set ruler\"当一行文字很长时取消换行\"set nowrap\"在状态栏显示正在输入的命令set showcmd\"设置历史记录条数set history=1000\"设置取消备份 禁止临时文件生成set nobackupset noswapfile\"突出现实当前行列\"set cursorline\"set cursorcolumn\"设置匹配模式 类似当输入一个左括号时会匹配相应的那个右括号set showmatch\"设置C/C++方式自动对齐set autoindentset cindent\"开启语法高亮功能syntax enablesyntax on\"指定配色方案为256色set t_Co=256\"设置搜索时忽略大小写set ignorecase\"设置在Vim中可以使用鼠标 防止在Linux终端下无法拷贝set mouse=a\"设置Tab宽度set tabstop=4\"设置自动对齐空格数set shiftwidth=4\"设置按退格键时可以一次删除4个空格set softtabstop=4\"设置按退格键时可以一次删除4个空格set smarttab\"将Tab键自动转换成空格 真正需要Tab键时使用[Ctrl + V + Tab]set expandtab\"设置编码方式set encoding=utf-8\"自动判断编码时 依次尝试一下编码set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1\"设置换行符为unixset ff=unix\"检测文件类型filetype on\"针对不同的文件采用不同的缩进方式filetype indent on\"允许插件filetype plugin on\"启动智能补全filetype plugin indent on\"Vundle 配置filetype off\"set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tomasr/molokai'Plugin 'scrooloose/nerdtree'Plugin 'Xuyuanp/nerdtree-git-plugin'Plugin 'vim-airline/vim-airline'Plugin 'vim-airline/vim-airline-themes'Plugin 'mattn/emmet-vim'Plugin 'jelera/vim-javascript-syntax'Plugin 'trusktr/seti.vim'Plugin 'terryma/vim-multiple-cursors'call vundle#end()filetype plugin indent on:map &lt;C-b&gt; :NERDTree&lt;CR&gt;let g:airline_powerline_fonts = 1if !exists('g:airline_symbols') let g:airline_symbols={}endiflet g:NERDTreeDirArrowExpandable = '&gt;'let g:NERDTreeDirArrowCollapsible = 'v'let g:airline#extensions#tabline#enabled = 1let g:airline#extensions#tabline#buffer_nr_show = 1let g:airline_theme='luna'set background=lightcolorscheme molokai 最终效果 参考链接 简书 Jetsly","link":"/2017/07/01/vim-config/"},{"title":"vim tips","text":"Tip 1: 解决windows gvim中backspace键不能往左删除 这个是因为在windows下的gvim是默认启用了vi兼容模式的，这种模式下backspace配置是空的，所以我们需要禁用vi兼容模式： set nocp backspace键的默认模式有三种： 1230 same as “:set backspace=” (Vi compatible)1 same as “:set backspace=indent,eol”2 same as “:set backspace=indent,eol,start” indent,eol,start解释如下： 123indent: 如果用了:set indent,:set ai 等自动缩进，想用退格键将字段缩进的删掉，必须设置这个选项。否则不响应。eol:如果插入模式下在行开头，想通过退格键合并两行，需要设置eol。start：要想删除此次插入前的输入，需设置这个 所以禁用vi兼容模式之后，我们可以设置backspace键为set backspace=2，然后不能使用backspace往左删除的问题消失。 Tip 2: 行间光标的上下移动：1gj Tip 3: 编辑成对符号中间的内容123456ci'、ci\"、ci(、ci[、ci{、ci&lt; - 分别更改这些配对标点符号中的文本内容di'、di\"、di(或dib、di[、di{或diB、di&lt; - 分别删除这些配对标点符号中的文本内容yi'、yi\"、yi(、yi[、yi{、yi&lt; - 分别复制这些配对标点符号中的文本内容vi'、vi\"、vi(、vi[、vi{、vi&lt; - 分别选中这些配对标点符号中的文本内容\" 另外如果把上面的i改成a可以连配对标点一起操作。","link":"/2017/07/01/vim-tips/"},{"title":"i3设置多屏显示","text":"最终果然还是奔向了平铺式管理器。只能说相见恨晚啊。i3下使用多显示器是挺方便的，当然windows下即插即用更讨喜。 先给出最终成果图: 在i3下使用多显示器首先就是要知道你各个显示器的名字，直接执行xrandr命令就能得到每一个视频接口输出的信息。 但首先就是要确定你想如何排布你的显示器,具体可以参考我的布局。 然后有两种方法可以设置多显示器： 第一种就是使用xrandr命令，命令如下： xrandr --output VGA1 --auto --pos 0x0 --output LVDS1 --pos 1920x312 简单解释如下： --output 后跟显示器名，--pos 后面跟显示器左上角的坐标。比如我的显示器排布方式的坐标就如下图： 我标注的两个坐标点即为--pos参数应该取的值。 第二种是利用arandr，arandr是一个图形化的xrandr客户端，界面如下： 界面显示的就是我自己的显示器布局，因为arandr执行之后，重启i3界面设置会失效，所以需要讲xrandr设置写入到i3配置里。具体配置可以从arandr导出，导出方式: layout - save as - nameyouset.sh，nameyouset.sh里的内容即为对应的命令行下的xrandr命令。","link":"/2017/08/10/use-external-display-on-i3wm/"},{"title":"LeetCode 20. Valid Parentheses解题报告","text":"这道题是菜鸡开始刷题的时候碰到的第一个小坎儿。刚开始几次submmit都没有成功。经过几次错误分析，发现题目要求的正确的字符串有几个特点： 字符个数为偶数 正确的字符串不管内容如何排布，总会有成对的括号在一起，一步步消除这种成对的括号，以及因为消除出现的新的成对括号，整个字符串就会消空。 基于上面两个特点，我自己编写了一个解法，可以说是惨不忍睹。但还是要贴出来以与后来的别人的简洁解法作对比： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def isPare(self, before, next): if before == '[' and next == ']': return 1 if before == '{' and next == '}': return 1 if before == '(' and next == ')': return 1 return 0 def popPare(self, s): i = 0 while len(s)&gt; 2: if self.isPare(s[i], s[i+1]): s.pop(i) s.pop(i) if i == 0: i = -1 else: i = i - 2 i = i + 1 if i &gt; len(s) - 2: break return s def isValid(self, s): \"\"\" :param s: str :return: bool \"\"\" s = list(s) if len(s) % 2 != 0: return False s = self.popPare(s) if len(s) != 2: return False elif self.isPare(s[0], s[1]): return True else: return False 我写了三个函数，第一个是用来检测字符配对，但这个其实用一个简单的词典就能完成。。我真是傻。 第二个用来检测所给字符串中相邻的字符是否配对，配对则消去。 在消去字符的时候我刚开始用的是remove方法。。我发现这个remove方法是根据传入内容从左开始的，这意味着重复的字符串里，remove的可能是左边的重复字符。后来还是用了pop函数，用了pop函数的时候我竟然还没有想到这道题可以用stack来快速解决啊。。我真是傻。 第三个就是判断函数，没啥好说的。。 好了，下面贴一个别人的python答案，使用了stack,很简洁。 1234567891011121314class Solution: # @return a boolean def isValid(self, s): stack = [] dict = {\"]\":\"[\", \"}\":\"{\", \")\":\"(\"} for char in s: if char in dict.values(): stack.append(char) elif char in dict.keys(): if stack == [] or dict[char] != stack.pop(): return False else: return False return stack == [] 前路还有很远。加油。","link":"/2017/10/20/leetcode-20/"},{"title":"使用pip一定更新所有包","text":"记录以备后用 python脚本 12345import pipfrom subprocess import callfor dist in pip.get_installed_distributions(): call(\"pip install --upgrade \" + dist.project_name, shell=True) 一种更简单点儿的方法 123pip freeze &gt; requirements.txtthen dopip install -r requirements.txt --upgrade","link":"/2017/10/25/how-to-use-pip-upgrade-all-outdated-packages/"},{"title":"Leetcode 1. Two Sum, 15. 3Sum, 16. 3Sum Closest解题报告","text":"Two Sum 问题描述： 给定一个整型的数组，返回和为指定值的两个元素的下标，可以假设只有一个答案。 这个问题写出解决代码很简单，第一想法就是两层遍历，先遍历前len(nums)-1个元素，再遍历对应的剩余元素。这种解法很直白，但是时间复杂度为O(n*n), 果然是提示时间超限的,所以要想办法降低时间复杂度. 如果引入一个存储已经遍历元素的buffer dict就能将时间复杂度降为O(n),具体代码如下： 123456789101112131415class Solution: def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if len(nums) &lt;= 1: return False buff_dict = {} for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i 代码分析：使用buff_dict存储已经遍历过的元素以及与该元素的和为制定值的解，这样的话如果以后遍历的元素为已经遍历的元素的解，那么这个元素就已经在字典里了。 3Sum 问题描述： 给定一个整型数组，检测其中是否有三个元素的和为0，返回所有符合要求的三个元素组成的数组。 在解决这个问题时，如果想起了Two Sum的解法，可能就会走弯路了。。下面上时间复杂度为O(n*n)的解法： 1234567891011121314151617181920212223class Solution(): def threeSum(self, nums): nums.sort() res = [] for i in range(len(nums) - 2): if i &gt; 0 and nums[i] == nums[i-1]: continue l = i + 1 r = len(nums) - 1 while l &lt; r: sum_result = nums[i] + nums[l] + nums[r] if sum_result &lt; 0: l = l + 1 elif sum_result &gt; 0: r = r - 1 else: res.append([nums[i], nums[l], nums[r]]) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1; r -= 1 return res 代码分析：没有什么好说的，这种问题就应该用这种解法，简单明了。 3Sum Closest 问题描述：给定一个整型数组，找到数组中的三个元素，使三者的和最接近与一个给定值。返回三者的和。可以假设满足要求的元素只有一组。 这个问题和3Sum问题解法一样，下面上时间复杂度为O(n*n)的解法： 12345678910111213141516171819class Solution(object): def threeSumClosest(self, nums, target): if len(nums) &lt; 3: return None nums.sort() res = nums[0] + nums[1] + nums[2] for i in range(len(nums)-2): l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s == target: return s if abs(s - target) &lt; abs(res - target): res = s if s &lt; target: l += 1 elif s &gt; target: r -= 1 return res 要耳聪目明才能吃嘛嘛香啊！","link":"/2017/11/03/summary-of-threeSum/"},{"title":"简易爬虫：爬取豆瓣电影top250","text":"爬虫目的说明：此爬虫简单到不能再简单了，主要内容就是爬取豆瓣top250电影页面的内容，然后将该内容导入了数据库。下面先上结果图： 爬虫部分代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344def getlist(listurl, result): time.sleep(2) headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36'} res = requests.get(listurl, headers=headers) soup = BeautifulSoup(res.text, 'html.parser') movielist = soup.select('.grid_view li') for m in movielist: rank = m.select('em')[0].text if len(m.select('.title')) &gt; 1: english_name = m.select('.title')[1].text.strip().strip('/').strip() else: english_name = \"No info\" chinese_name = m.select('.title')[0].text info_str = m.select('.info .bd p')[0].text.strip().replace(u'\\xa0', u' ') info_list = info_str.split('\\n') time_list = info_list[1].strip().split('/') movie_time = time_list[0].strip() movie_place = time_list[1].strip() movie_type = time_list[2].strip() director_list = info_list[0].strip(u'导演:').split(' ') director = director_list[0].strip() if len(director_list) &gt; 1: main_actor = director_list[1].strip().strip(u\"主演:\").strip() else: main_actor = u\"暂无信息\" if m.select('.inq'): comments = m.select('.inq')[0].text.strip() else: comments = 'None' movie.append(u'排名: ' + rank + '\\n' + u'电影名: ' + chinese_name + '\\n' + u'导演: ' + director + '\\n' + u'主演: ' + main_actor + '\\n' + u'时间: ' + movie_time + '\\n' + u'产地： '+ movie_place + '\\n'+ u'类型： ' + movie_type + '\\n' + u'评论: ' + comments + '\\n') data_movies = (rank, chinese_name, english_name, director, main_actor, movie_time, movie_place, movie_type, comments) result.append(data_movies) #获取下一页 if soup.select(u'.next a'): asoup = soup.select(u'.next a')[0][u'href'] Next_page = lurl + asoup getlist(Next_page, result) else: print('Done') return result, movie 返回的resutl以及movie都是列表，result用来存储保存在数据库中的内容，movie用来保存写入文件中的内容。之所以分开保存是因为，写入文件的每个元素都要加上诸如”导演“此类的说明词汇，以便于理解;而数据库已经有了列名，所以不需要这些说明词汇。 数据库导入部分代码：1234567891011121314151617181920212223242526272829303132#连接数据库db = MySQLdb.connect(host=\"localhost\", user=\"root\", passwd=\"\", db=\"spider\", use_unicode=True, charset=\"utf8\")cursor = db.cursor()cursor.execute(\"DROP TABLE IF EXISTS MOVIE\")sql = \"\"\"CREATE TABLE MOVIE ( RANK INT(4), CHINESE_NAME CHAR(100), ENGLISH_NAME CHAR(100), DIRECTOR CHAR(100), MAIN_ACTORS CHAR(100), TIME CHAR(100), PLACE CHAR(100), TYPE CHAR(100), COMMENT CHAR(100) )\"\"\"cursor.execute(sql)lurl = 'https://movie.douban.com/top250'movie = []result = []result, movies = getlist(lurl, result)print(len(result))#插入获取的内容到数据库cursor.executemany( \"\"\" INSERT INTO MOVIE (RANK, CHINESE_NAME, ENGLISH_NAME, DIRECTOR, MAIN_ACTORS, TIME, PLACE, TYPE, COMMENT) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)\"\"\", result )db.commit() #commit之后数据库才会改动cursor.close()db.close() Tips: 爬虫部分：由于页面显示千差万别，所以爬虫部分代码最开始不要有对内容太细化的处理。太细化的处理会导致某些小问题的出现，以至于爬虫不能正常进行。 数据库导入部分：数据库导入出现的错误大多就是编码错误，所以注意这些就行了。","link":"/2017/11/09/simple-spider-with-python/"},{"title":"使用nginx和uwsgi部署Django应用","text":"这段儿时间使用Python3.6 + Django 1.11模仿慕课网某课做了一个Django小项目，已经完成了基本功能。在基本功能完成之后，自然想部署起来，既可以学习一下部署相关知识，也可以展示一下自己的成果。本次部署采用Nginx+uWSGI的方式。至于为什么采用这种方式，uwsgi官方文档里有一段话说的很清楚： A web server faces the outside world. It can serve files (HTML, images, CSS, etc) directly from the file system. However, it can’t talk directly to Django applications; it needs something that will run the application, feed it requests from web clients (such as browsers) and return responses.A Web Server Gateway Interface - WSGI - does this job. WSGI is a Python standard.uWSGI is a WSGI implementation. 部署完成后，整个的功能栈结构如下： web client the web server(nginx) the socket uwsgi Django```1234567891011121314部署过程看了很多个教程，也翻看了不少Nginx和uwsgi的文档，但是坑永远都在，当你踩完之后它才会消失，所以记录下自己这次部署的记录，以便以后参考。### 1. 安装nginx&gt; 本次使用的是腾讯云的服务器，系统为Centos7，这里有一篇写的很好的文档：[centos7安装nginx](https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7), 当然，为了省去跳转的功夫，这里将过程记录如下：```shell# 1. add the Centos7 EPEL repository:sudo yum install epel-release# 2. Install nginxsudo yum install nginx# 3. start nginxsudo systemctl start nginx 在Nginx启动之后，对Nginx的便捷操控命令为：1234# 1. reloadsudo nginx -s reload# 2. stopsudo nginx -s stop 2. 安装mariadb1sudo yum install mariadb-server 2.1 在安装mariadb之后，首先修改mariadb的一些设置，使其支持中文：1234567891011# yum安装的mariadb主配置文件在/etc/my.cnf， 并且在这个文件中包含/etc/my.cnf.d路径下的所有文件。# 1. 编辑该目录下的client.cnf文件，在[client]下添加：default-character-set=utf8# 2. 编辑my.conf.d目录中的mysql-clients.cnf,在[mysql]下添加：default-character-set=utf8# 3. 编辑my.conf.d目录中的server.cnf，在[mysqld]下添加：init_connect='SET collation_connection = utf8_general_ci'init_connect='SET NAMES utf8'character-set-server=utf8collation-server=utf8_general_ciskip-character-set-client-handshake 2.2 配置数据库远程访问：123456789# 1. 设置bind ipvim /etc/my.cnf# 在[mysqld]下面加上一行：bind-address = 0.0.0.0# 2. 进入mysql，执行下面命令GRANT ALL PRIVILEGES ON *.* TO 'YOUUSERNAME'@'%' IDENTIFIED BY 'YOURPASSWORD' WITH GRAND OPTION;FLUSH PRIVILEGES;# 3. 重启mariadb服务器systemctl restart mariadb.service 在完成上一步后，请开放对应的数据库端口, 自己机器防火墙要开启，对应云服务器厂商的防火墙规则也要设置开启。 在机器上简单设置开放3306端口教程如下：123456# 首先查看3306端口是否开放firewall-cmd --query-port=3306/tcp# 返回为no/yes# 然后如果是no，则放行该端口并重新加载防火墙配置：firewall-cmd --permanent --add-port=3306/tcpfirewall-cmd --reload 到目前为止，数据库已经支持中文显示，并且已经可以远程访问，数据库模块设置结束。 3. 安装uwsgi1pip install uwsgi 4. 开始配置4.1 测试uwsgi与Django链 首先确认你的Django项目在python manage.py runserver 0.0.0.0:8000时运行完全良好。（同时确认你的云服务器8000端口是开启的） 如果1通过，那么就可以使用uwsgi试一下了：1uwsgi --http :8000 --module mysite.wsgi 其中，mysite是你的Django项目名称，wsgi为你Django默认生成的主app文件夹下的wsgi.py文件。如果项目仍然能正常运行，那么说明uwsgi与Django链是完好的。 4.2 配置nginx 你可以在你的项目下新建一个conf文件夹，用来存放Nginx以及uwsgi的配置文件，假设Nginx配置文件为mysite_nginx.conf 12345678910111213141516171819202122232425262728293031323334# mysite_nginx.conf# the upstream component nginx needs to connect toupstream django { # server unix:///path/to/your/mysite/mysite.sock; # for a file socket server 127.0.0.1:8001; # for a web port socket (we'll use this first)}# configuration of the serverserver { # the port your site will be served on listen 80; # the domain name it will serve for server_name example.com; # substitute your machine's IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media { alias /path/to/your/mysite/media; # your Django project's media files - amend as required } location /static { alias /path/to/your/mysite/static; # your Django project's static files - amend as required } # Finally, send all non-media requests to the Django server. location / { uwsgi_pass django; include /path/to/your/mysite/uwsgi_params; # the uwsgi_params file you installed }} 配置完Nginx之后，就要部署你自己的静态文件： 首先，在setting文件中加入STATIC_ROOT 1STATIC_ROOT = os.path.join(BASE_DIR, \"static/\") 然后，执行：python manage.pu collectstatic, 并重启Nginx。 然后就是配置uwsgi， 假设配置文件为：uwsgi.ini 1234567891011121314151617181920212223[uwsgi]# Django-related settings# the base directory (full path)chdir = /home/django/EduSite# Django's wsgi filemodule = edusite_final.wsgi# the virtualenv (full path)virtualenv = /home/django/.virtualenvs/edusite111# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 10# the socket (use the full path to be safesocket = 127.0.0.1:8001# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = truelogto = /tmp/mylog.log 然后启动uwsgi： uwsgi -i /path/to/your/uwsgi.ini &amp; 普遍的，大家的部署教程都是这么写的，但是在这个部署过程中，我们还需要注意的就是nginx相关的权限问题，不然的话————你去踩踩坑就知道了。","link":"/2018/03/21/deploy-django-app-with-nginx-and-uwsgi/"},{"title":"StackOverflow翻译之Python中的参数引用问题","text":"How do I pass a variable by reference?问题: Python文档并没有说清楚参数究竟是按引用传递还是按值传递的，下面的代码创造了这个不能改变的值‘Original’: 12345678class PassByReference: def __init__(self): self.variable = 'Original' self.change(self.variable) print(self.variable) def change(self, var): var = 'Changed' 有没有方法让我可以按照引用把这个参数传递进去？ Blair Conrad的回答（2106票）： 参数是通过assignment传递过去的。背后的原理有双重性： 参数是通过对象引用传递的（但是这个引用是值传递的）； 一些数据类型是可变的，但是另外一些是不可变的。 所以： 如果你传递一个可变对象到方法里，这个方法得到指向同一个对象的引用，然后你可以按照你的想法改变它。但是如果你在方法中重指了这个引用，那么外部环境是完全不知情的，当你完成了对重指的引用的操作之后，方法外部的引用仍然是指向最初的那个对象的； 如果你传递一个不可变对象到方法里，你仍然不能重指外部的引用，你甚至没有办法改变这个对象（在方法里） 为了更形象，让我们看几个例子： 列表 - 可变类型 让我们尝试着改变传递到方法中的列表： 12345678910def try_to_change_list_contents(the_list): print('got', the_list) the_list.append('four') print('changed to', the_list)outer_list = ['one', 'two', 'three']print('before, outer_list = ', outer_list)try_to_change_list_contents(outer_list)print('after, outer_list = ', outer_list) 结果： 1234before, outer_list = ['one', 'two', 'three']got ['one', 'two', 'three']changed to ['one', 'two', 'three', 'four']after, outer_list = ['one', 'two', 'three', 'four'] 鉴于这个传入的参数是outer_list的一个引用，而不是它的一个复制，我们可以使用改变列表的方法去改变它，而且这个改变会反映到外部环境。 现在让我们看一下如果我们尝试改变作为参数传递进来的引用的时候会发生什么？ 12345678910def try_to_change_list_reference(the_list): print('got', the_list) the_list = ['and', 'we', 'can', 'not', 'lie'] print('set to', the_list)outer_list = ['we', 'like', 'proper', 'English']print('before, outer_list = ', outer_list)try_to_change_list_reference(outer_list)print('after, outer_list = ', outer_list) 结果： 1234before, outer_list =['we', 'like', 'proper', 'English']got ['we', 'like', 'proper', 'English']set to ['and', 'we', 'can', 'not', 'lie']after, outer_list = ['we', 'like', 'proper', 'English'] 由于这个the_list参数是通过值传递的（是指传入的引用是值传递的），给它分配一个新列表并对外界代码没有作用。这个the_list是外界outer_list引用的一个副本，当我们把the_list指向一个新列表时，就没有办法去改变outer_list指向的对象了。 字符串—不可变类型 字符串是不可变的，所以我们没有方法去改变字符串的内容，现在，让我们尝试着改变它的引用 12345678910def try_to_change_string_reference(the_string): print('got', the_string) the_string = 'In a kingdom by the sea' print('set to', the_string)outer_string = 'It was many and many a year ago'print('before, outer_string = ', outer_string)try_to_change_string_reference(outer_string)print('after, outer_string = ', outer_string) 结果是显而易见： 1234before, outer_string = It was many and many a year agogot It was many and many a year agoset to In a kingdom by the seaafter, outer_string = It was many and many a year ago 同样的，由于the_string参数是通过值传递进来的，将它指向一个新字符串对外部环境并没有什么影响。这个the_string是outer_string引用的一个副本，我们将the_string指向一个新字符串的时候，我们就没有方法去改变outer_string指向的那个对象了。 我希望这样能把事情说的更清楚了。 更新：这样并没有回答题主的问题：我们能不能按照真实引用传递参数？让我们来看一看。 我们如何解决这个问题？ 按照@Andrea’s的回答，你可以返回这个新值，这并不会改变参数传递的方式，但能够让你得到你想得到的信息： 123456def return_a_whole_new_string(the_string): new_string = something_to_do_with_the_old_sting(the_string) return new_string# 然后你可以像这样调用它my_string = return_a_whole_new_string(my_string) 如果你是在不想使用一个返回值，你可以创建一个类去保存你的值然后把它传入到函数中，或者使用一个已经存在的类，想一个列表一样： 123456789def user_a_wrapper_to_simulate_pass_by_referece(stuff_to_change): new_string = something_to_do_with_the_old_string(stuff_to_change[0]) stuff_to_change[0] = new_string# 然后你可以想这样调用它wrapper = [my_string]user_a_wrapper_to_simulate_pass_by_reference(wrapper)do_something_with(wrapper[0]) 虽然这样看起来有些繁琐。","link":"/2018/03/26/para-pass-in-python-of-StackOverflow/"},{"title":"StackOverflow翻译之浮点数键值覆盖整型键值","text":"Why can a floating point dictionary key overwrite an integer key with the same value? 问题: 我正在mypythonquiz答题,然后问题#45是回答下面代码的输出结果： 12345678910confusion = {}confusion[1] = 1confusion['1'] = 2confusion[1.0] = 4sum = 0for k in confusion: sum += confusion[k]print sum 代码输出结果为6，因为键1.0把1替换了。这让我觉得有些意外，这是一个有用的语言特性吗？ Bakuriu的高票回答（76votes） 首先，这个现象已经在hash函数的官方文档里解释的很清楚了: hash(object) Return the hash value of the object(if it has one). Hash values are integers.They are used to quickly compare dictionary keys during a dictionary loopup. Numeric values that compare equal have the same hash value(even if they are of different types, as is the case for 1 and 1.0). Curabitur blandit tempus porttitor. Nullam quis risus eget urna mollis ornare vel eu leo. Nullam id dolor id nibh ultricies vehicula ut id elit. 其次，object.__hash__文档里指出了hashing的一个限制： object.hash(self) Called by built-in function hash() and for operations on members of hashed collections including set, frozenset, and dict.__hash__() should return an integer.The only required property is that objects which compare equal have the same hash value; 这并不是python独有的。Java也有类似的提醒：如果你打算实现hashCode函数，那么为了实现正常功能，你必须依据这样的准则实现：x.euqals(y)等价于x.hashCode() == y.hashCode(). 所以，在python中1.0 == 1，因此对hash函数来说，它就被强制性的实现hash(1.0) == hash(1). 副作用就是在字典中，1.0和1作为键值是没有区别的，这也就导致了题目中的现象。","link":"/2018/05/30/tranlation-of-float-key-override-in-dict-StackOverflow/"},{"title":"树形dp题总结","text":"此类题特征：需要遍历一遍二叉树节点，判断是否满足条件。且一般情况可以由下往上，在下层构建好所需信息之后，传到上层，然后在上层根据条件做进一步的信息整合，直到遍历完成之后返回整合完毕的信息。 1. 求二叉树中的最长距离 假设二叉树一个节点可以向上也可以向下，那么二叉树上的一个节点就能到达二叉树上其他任意节点，一个节点到另一个节点的距离定义为到达该节点的最短路径（也就是不绕路)，求二叉树中的最长距离。 分析： 这个题明显的我们需要遍历二叉树，找到每一个节点到其他节点的最长距离然后比较返回最长的那一个。如果我们就这么想，实现起来就挺麻烦。如果换一种思考方式，我们找以每一个节点为头的子树上的最长距离，然后返回最大的那一个就行了。以每一个节点为头就给够了启发——递归啊兄弟。下面分析情况： 最长距离在该节点左子树上, 此时需要知道左子树上的最长距离； 最长距离在该节点右子树上, 此时需要知道右子树上的最长距离； 最长距离包括该节点, 此时需要知道左子树高度，右子树高度； 所以，综上，我们需要子节点每次给我们返回自己的最长距离以及高度，下面就可以构造返回类型了：hight, max_dis，代码如下： 代码：1234567891011121314151617def get_max_dis(root): \"\"\"得到二叉树上的最远距离\"\"\" if root is None: return 0, 0 left_hight, left_max_dis = get_max_dis(root.left) right_hight, right_max_dis = get_max_dis(root.right) hight = max(left_hight, right_hight) + 1 # case 1 p1 = left_max_dis # case 2 p2 = right_max_dis # case 3 p3 = left_hight + right_hight + 1 return hight, max(p1, p2, p3) 2. 验证是否是二叉平衡树 明显我们可以判断以每个节点为头结点的子树是否是二叉平衡树，每个子节点需要给我们返回自己是不是平衡树，以及自己的高度，构造返回类型：is_sbt, height。 代码：1234567891011121314151617def is_sbt(root): \"\"\"验证是否是二叉平衡树\"\"\" if root is None: return True, 0 isbst_left, height_left = is_sbt(root.left) isbst_right, height_right = is_sbt(root.right) if not isbst_left or not isbst_right: return False, -1 if isbst_left and isbst_right and abs(height_left - height_right) &gt; 1: return False, -1 height = max(height_left, height_right) + 1 return True, height 3. 得到二叉树中最大的二叉搜索树的大小 老套路，以每个子节点给头结点，得到需要的信息。 分析情况： 最大bst在该节点左子树上，此时需要左子树上最大bst大小； 最大bst在该节点右子树上，此时需要在右子树上最大bst大小； 最大bst是以该节点为头的二叉树，此时需要左子树是不是bst，右子树是不是bst，左子树的最大值，右子树的最小值四个条件辅助判断； 综上，子节点需要提供给我们的返回类型包括： is_bst：是否为二叉搜索树； max_subbst：包含的最大二叉搜索树大小；` max_max：包含的最大值； min_min：包含的最小值； 代码：123456789101112131415161718192021222324def get_max_subbst(root): \"\"\"得到二叉树中最大的二叉搜索树大小\"\"\" if root is None: return True, 0, -sys.maxsize, sys.maxsize is_bst_left, max_subbst_left, max_left, min_left = get_max_subbst( root.left) is_bst_right, max_subbst_right, max_right, min_right = get_max_subbst( root.right) # case 1 p1 = max_subbst_left # case 2 p2 = max_subbst_right # case 3 p3 = -sys.maxsize if is_bst_left and is_bst_right and root.val &gt; max_left and root.val &lt; min_right: p3 = max_subbst_left + 1 + max_subbst_right max_subbst = max(p1, p2, p3) is_bst = max_subbst == p3 max_max = max(root.val, max_left, max_right) min_min = min(root.val, min_left, min_right) return is_bst, max_subbst, max_max, min_min 总结：从上面三个例子可以看出，此类问题最复杂的地方算是分析情况了，然后就是构建base case，尤其是第三题，在遍历到的节点为空的时候，怎么构建base case给上级节点提供正确的不影响后序判断的信息是很重要的。","link":"/2018/08/15/summary-of-tree-mode-dp-questions/"},{"title":"递归时间复杂度计算：master公式","text":"老忘，记下来随时翻一翻。 $T(n) = aT(\\frac{n}{b}) + O(n^d) $其中： $\\log_{b}a &gt; d \\quad \\Rightarrow \\quad O(n^{\\log_{b}a})$&emsp;&emsp;&emsp;&nbsp;&nbsp;$\\log_{b}a &lt; d \\quad \\Rightarrow \\quad O(n^{d})$&emsp;&emsp;&emsp;&nbsp;&nbsp;$\\log_{b}a = d \\quad \\Rightarrow \\quad O(n^{d}*\\log{n})$ 其中a为递归中子递归个数， n/b为子递归的数据规模。","link":"/2018/09/11/master-formula-of-recursive/"},{"title":"给Jekyll博客添加Latex公式支持","text":"昨天不清楚Jekyll能不能够支持Latex公式，所以写master的公式的时候就直接ipad手写截图了，今天还要在博客里写一些公式，就找了找有没有解决方法，果然是有的，体验非常棒。 工具官网： MathJax 使用方法： 把下面的JS调用代码以及配置插入到你Jekyll博客的header文件中： 123456789&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } });&lt;/script&gt;&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt; Note: 默认的MathJax配置和Latex有所不同，主要体现在默认的inline公式是要用\\( \\)来标示，而Latex是用两个\\$符号。所以上面配置里将默认修改成了Latex的标示方法。 效果如下： $$W (s_{i}\\leftarrow s_{j})=\\frac{1}{1+\\exp[ (p_{i}-p_{j})/K]}$$ refs：StackOverflow","link":"/2018/09/13/add-eqution-support-in-jekyll/"},{"title":"深入浅出mysql数据库开发 第二章学习笔记","text":"motivation - 小知识点老是忘，好记性不如烂笔头。 sql语句可以划分为三类： DDL(Data Definition Languages)语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用关键字包括create、drop、alter; DML(Data Manipulation Language)语句：数据操作语句，也就是增删改查。主要有insert、delete、update和select等； DCL(Data Control Language)语句：数据控制语句。主要是用于控制许可和访问级别，主要有grant, revoke。 以下所写语句均为实际操作语句而不是语法说明，例子一直是围绕一个test数据库中的emp和dept表。 DDL建库切库：12create database test;use test; 建表：12345create table emp( ename varchar(20), hiredate date, sal decimal(10, 2), deptno int(2)); 如果想要简单查看表结构：desc emp; 如果想要查看详细建表语句：show create table emp \\G。 修改表:1234567891011121314# 修改表名alter table emp rename emps;# 增加表字段, first代表新加字段不会被加到最后，而是放到开头alter table emp add age int(3) first;# 删除表字段alter table emp drop age;# 字段改名或者修改定义alter table emp change age age1 int(3);# 修改字段并改变字段顺序alter table emp modify age int(4) after ename; DML增删改查12345678910111213141516171819202122232425262728293031# 增insert into emp values('lisa', '2000-01-01', 2000, 1);# 部分增insert into emp(ename, sal) values('dony', 1000);# 一次性增多个insert into emp values('bob', '2001-01-01', 3000, 2), ('david', '2002-01-01', 1000, 4);# 改update emp set sal=3000 where ename='lisa';# 删delete from emp where sal=2000;# 查select * from emp;# 部分查select ename from emp ;# 条件查select ename form emp where sal &gt; 2000;select * from emp where ename='david';# 去重查select distinct deptno from emp;# 排序select * from emp order by deptno;select * from emp order by deptno, sal;# 限制结果数量select * from emp limit 1; -- 返回的是从开头开始的1条数据# limit后面可以加两个参数，第一个为起始索引, 起始索引默认为0，第二个为限制结果行数select * from emp limit 1, 2; -- 返回的是从第二条数据开始的两条数据 聚合很多情况下，用户都需要进行一些汇总操作，比如统计整个公司的人数或者统计每个部分的人数，这个时候就要用到聚合操作，由于聚合操作比较多这里先给出语法： 123456select [field1, field2, ...fieldn] fun_namefrom tablename[where where_condition][group by field1, field2,...fieldn[with rollup]][having where_condition] 参数说明如下： fun_name表示聚合函数，常用的有sum, count(*), max, min; group by关键字表示要进行分类聚合的字段； with rollup是可选的，表明是否对分类聚合后的结果进行再汇总； having关键字表示对分类后的结果再进行条件的过滤。 例子：1234567891011# 统计公司各个部门的人数：select deptno, count(1) from emp group by deptno;# 统计公司各个部门人数的同时统计总人数（用到with rollup对分类聚合后的结果进行汇总）select deptno, count(1) from emp group by deptno with rollup;# 统计人数大于1的部门：select deptno, count(1) from emp group by deptno having count(1) &gt; 1;# 统计员工的薪水总额、最高和最低薪水：select sum(sal), max(sal), min(sal) from emp; 表连接从大类上，表连接分为内连接和外连接，它们之间的最主要区别是内连接仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录。最常用的是内连接。 为了测试表连接我们创建一个新表dept，包含部门编号和部门名称：123create table dept( deptno int(2), deptname varchar(20)); 1select ename, deptname from emp, dept where emp.deptno=dept.deptno; 外连接有分为左连接和右连接，具体定义如下： 左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录； 右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录。 12345# 左连接select ename, deptname from emp left join dept on emp.deptno=dept.deptno;# 右连接select ename, deptname from dept right join emp on dept.deptno=emp.deptno; 子查询有些情况下，当进行查询的时候，需要的条件是另外一个select语句的结果，这个时候就要用到子查询。用于子查询的关键字主要包括in、not in、=、!=、exits、not exists等。 12345# 从emp表中查询出所有部门在dept表中所有记录：select * from emp where deptno in(select deptno from dept);# 上面那个子查询有些时候可以转换为表连接select emp.* from emp, dept where emp.deptno=dept.deptno; 记录联合语法：123456select * from t1union | union allselect * from t2...union | union allselect * from tn; union和union all的区别就是union会做去重处理； 123select deptno from empunion allselect deptno from dept; 其实就是把结果排下来。。不知道这有啥用。。 DCLDCL语句主要是用来管理对象权限，给用户z1添加对sakila数据库添加查询和插入权限以及再取消插入权限的语句如下： 12345# 赋予select和insert权限grant select, insert on sakila.* to 'z1'@'localhost' identified by '123';# 收回insert权限revoke insert on sakila.* from 'z1'@'localhost';","link":"/2018/09/19/reading-notes-of-chapter-2-in-depth-explantion-of-mysql/"},{"title":"KMP算法","text":"KMP算法用于检查短字符串是否在某个长字符串中。 算法过程 使用kmp解LeetCode28题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384## [28] Implement strStr()## https://leetcode.com/problems/implement-strstr/description/## algorithms# Easy (29.86%)# Total Accepted: 316K# Total Submissions: 1.1M# Testcase Example: '\"hello\"\\n\"ll\"'## Implement strStr().## Return the index of the first occurrence of needle in haystack, or -1 if# needle is not part of haystack.## Example 1:### Input: haystack = \"hello\", needle = \"ll\"# Output: 2### Example 2:### Input: haystack = \"aaaaa\", needle = \"bba\"# Output: -1### Clarification:## What should we return when needle is an empty string? This is a great# question to ask during an interview.## For the purpose of this problem, we will return 0 when needle is an empty# string. This is consistent to C's strstr() and Java's indexOf().##class Solution: def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" if not needle: return 0 h_length, n_length = len(haystack), len(needle) if h_length &lt; n_length: return -1 next_arr = self.get_next_arr(needle) i = j = 0 while i &lt; h_length and j &lt; n_length: if haystack[i] == needle[j]: i += 1 j += 1 elif next_arr[j] == -1: i += 1 else: j = next_arr[j] return i - j if j == n_length else -1 def get_next_arr(self, needle): length = len(needle) if length &lt; 2: return [-1] next_arr = [0 for i in range(length)] next_arr[0], next_arr[1] = -1, 0 i, cur = 2, 0 while i &lt; length: if needle[cur] == needle[i-1]: next_arr[i] = cur + 1 cur = next_arr[i] i += 1 elif cur &gt; 0: cur = next_arr[cur] else: next_arr[i] = 0 return next_arr","link":"/2018/09/20/kmp/"},{"title":"Jekyll tips","text":"使用jekyll博客中用到的小技巧 1. 指定Kramdown的标题id今儿给人分享一个包含有id的链接的时候发现一个问题：标题为中文的id会是乱码并且很长很长，就想着有没有解决方法，然后发现Kramdown的确提供了自定义标题id的功能，使用方法就是在标题后面加上花括号然后里面写上自定义id就好了。 还有一个要注意的事情就是花括号里单词之间不能有空格。 2. 给代码块添加行号1234Kramdown: syntax_highlighter_opts: block: line_numbers: true","link":"/2018/09/21/jekyll-tips/"},{"title":"在vim中使用snippets","text":"推荐使用vim-plug作为vim包管理器，轻量且能异步更新，还支持插件分支。 1. 所用插件1234567\" vim-plug配置插件方式\" supertab用来防止使用tab展开snippet与youcompleteme的tab补全发生冲突Plug 'ervandew/supertab'\" ultisnips是引擎Plug 'SirVer/ultisnips'\" 所有常用snippet都在vim-snippets里Plug 'honza/vim-snippets' 2. 插件设置，以及YCM与UltiSnips不冲突的设置方法具体supertab插件以及UltiSnip插件设置如下：123456789101112\" make YCM compatible with UltiSnips (using supertab)let g:ycm_key_list_select_completion = ['&lt;C-n&gt;', '&lt;Down&gt;']let g:ycm_key_list_previous_completion = ['&lt;C-p&gt;', '&lt;Up&gt;']let g:SuperTabDefaultCompletionType = '&lt;C-n&gt;'\" better key bindings for UltiSnipsExpandTriggerlet g:UltiSnipsSnippetDirectories = ['~/.vim/UltiSnips', 'UltiSnips']let g:UltiSnipsExpandTrigger = \"&lt;tab&gt;\"let g:UltiSnipsJumpForwardTrigger = \"&lt;tab&gt;\"let g:UltiSnipsJumpBackwardTrigger = \"&lt;s-tab&gt;\"\" If you want :UltiSnipsEdit to split your window.let g:UltiSnipsEditSplit=\"vertical\" 这样YouCompleteMe就被绑定到了Ctrl+n，然后这个快捷键又被SuperTab绑定到tab。 3. 自定义snippet可以使用UltiSnips的语法自定义代码块，比如jekyll博客，我们每次新建博客的时候都要加入固定的博客头，我们想要实现输入head然后按下tab键自动补全固定表头。 自定义snippet如下：12345678910111213141516171819202122232425# ~/.vim/bundle/UltiSnips/markdown.snippetssnippet head \"Jekyll post header\" b---title: ${1:title}layout: postpublished: falseguid: `!pimport uuidif not snip.c: guid = uuid.uuid4().hexsnip.rv = guid`date: `!v strftime(\"%Y-%m-%d %H:%M:%s\")`categories: [${2:Python}]tags: [${3:code, python}]---**目录：*** Kramdown table of contents{:toc .toc}* * *${0}endsnippet# vim:ft=snippets: UltiSnips自定义snippet的语法为:snippet trigger_word [&quot;description&quot; [options] ] 在上例中，我们的trigger_word为head，description为jekyll post header, options为b，b意味着只有trigger_word在行首的时候，才执行对应操作; 其中的变量${n}，代表是第几个可以用tab跳转的可输入块，默认开始时光标停留在${1}上，最后一个可跳转位置是${0}。","link":"/2018/09/23/vim-snippets/"},{"title":"Manacher算法","text":"Manacher算法用作求字符串中的最长回文串长度。 算法过程 利用manacher求解LeetCode第五题最长回文子串问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384## [5] Longest Palindromic Substring## https://leetcode.com/problems/longest-palindromic-substring/description/## algorithms# Medium (25.62%)# Total Accepted: 370.8K# Total Submissions: 1.4M# Testcase Example: '\"babad\"'## Given a string s, find the longest palindromic substring in s. You may assume# that the maximum length of s is 1000.## Example 1:### Input: \"babad\"# Output: \"bab\"# Note: \"aba\" is also a valid answer.### Example 2:### Input: \"cbbd\"# Output: \"bb\"###class Solution: def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" if s is None: return '' length = len(s) if length &lt; 2: return s s = self.str_trans(s) length = len(s) res = [1 for i in range(length)] right = c = -1 for i in range(length): res[i] = min(res[2*c-i], right-i) if right &gt; i else 1 while i-res[i] &gt; -1 and i+res[i] &lt; length: if s[i-res[i]] == s[i+res[i]]: res[i] += 1 else: break res[i] -= 1 if i + res[i] &gt; right: right = i + res[i] c = i lp = max(res) lp_index = res.index(lp) lp = s[lp_index-lp:lp_index+lp+1] return lp.replace('#', '') def str_trans(self, s): s = list(s) for i in range(len(s)): s[i] = '#' + s[i] s.append('#') return ''.join(s)def main(): s = 'babad' ex = Solution() print(ex.longestPalindrome(s))if __name__ == \"__main__\": main()","link":"/2018/09/27/manacher/"},{"title":"使用fail2ban防止ssh暴力登录","text":"今儿中午，心血来潮统计了一下ssh失败次数，发现最高的一个ip有4000多次登录失败记录。这让我想起了那个传闻：暴露在外网的机器，如果不做防护，八个小时内就易主了。所以找了找防止暴力尝试的方法，发现现在常规方法就是使用fail2ban监控，然后自动禁用可疑ip，部署方法如下： 安装fail2ban1yum -y install fail2ban 请注意防火墙软件是firewalld而不是iptables 12345678# 查看状态firewall-cmd --state# 启动firewalldsystemctl start firewalld# 开机启动systemctl enable firewalld 默认的firewalld会禁用所有端口连接，因此你需要手动的放行端口，比如你的博客服务的web端口：1234567firewall-cmd --zone=public --add-port=80/tcp --permanent# 重载配置firewall-cmd --reload# 查看已经放行的端口firewall-cmd --zone=public --list-ports 配置fail2banfail2ban的配置文件位于/etc/fail2ban/， 我们在该目录新建一个自定义配置文件jail.local然后加入如下信息：12345678910111213141516[DEFAULT]ignoreip = 127.0.0.1/8bantime = 86400findtime = 600maxretry = 5banaction = firewallcmd-ipsetsender = email@email.comsenername = Fail2Banaction = %(action_mwl)s[sshd]enabled = truefilter = sshdport = 22action = %(action_mwl)slogpath = /var/log/secure 启动fail2ban1systemctl start fail2ban 查看fail2ban日志以及ip禁用列表12345# 查看日志tail -F /var/log/fail2ban# 查看禁用ipfail2ban-client status sshd","link":"/2018/09/27/use-fail2ban-to-protest-your-vps/"},{"title":"BFPRT算法——Top-K问题求解","text":"BFPRT算法是一种用来求解Top-K问题的算法，其时间复杂度可以减小到O(n)。 基本过程 使用BFPRT求无序数组中第k小的元素，k从1开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# -*- coding=utf-8 -*-import randomimport timeclass BFPRT(): \"\"\"BFPRT算法实现： BFPRT算法用来求解Top-K问题，时间复杂度可以做到严格的O(n)。 \"\"\" def bfprt(self, nums, k): \"\"\"求得nums数组中第k小的元素，k从1开始 Args: nums (list): 给定数组 k (int): 所求元素位置 Returns: num_type: 所求元素 \"\"\" if not nums or not k: return None length = len(nums) if k &gt; length: return None nums = list(nums) return self.process(nums, k-1, 0, length-1) def process(self, nums, k, begin, end): if begin == end: return nums[begin] pivot = self.get_median_of_medians(nums, begin, end) cur_range = self.partition(nums, pivot, begin, end) if k &gt;= cur_range[0] and k &lt;= cur_range[1]: return nums[k] elif k &lt; cur_range[0]: return self.process(nums, k, begin, cur_range[0]-1) else: return self.process(nums, k, cur_range[1]+1, end) def partition(self, nums, pivot, begin, end): left = begin - 1 cur = begin right = end + 1 while cur &lt; right: if nums[cur] == pivot: cur += 1 elif nums[cur] &lt; pivot: left += 1 self.swap(nums, left, cur) cur += 1 else: right -= 1 self.swap(nums, right, cur) return left+1, right-1 def get_median_of_medians(self, nums, begin, end): \"\"\"取得中位数数组中位数\"\"\" cur_len = end - begin + 1 offset = 0 if cur_len % 5 == 0 else 1 medians = [0 for i in range(cur_len//5 + offset)] for i in range(len(medians)): begin_idx = begin + i * 5 end_idx = begin_idx + 4 medians[i] = self.get_median(nums, begin_idx, min(end_idx, end)) return self.process(medians, len(medians)//2, 0, len(medians)-1) def get_median(self, nums, begin, end): \"\"\"取得给定范围的上中位数\"\"\" self.insert_sort(nums, begin, end) mid = (begin + end) // 2 return nums[mid] def insert_sort(self, nums, begin, end): for i in range(begin+1, end+1): for j in range(i, begin, -1): if nums[j] &lt; nums[j-1]: self.swap(nums, j, j-1) else: break def swap(self, nums, i, j): nums[i], nums[j] = nums[j], nums[i]class Check(): \"\"\"对数器\"\"\" def generate_nums(self, max_length, max_value): length = random.randint(0, max_length) nums = [random.randint(-max_value, max_value) for i in range(length)] return numsdef main(): nums = [4, 5, 3, 2, 1, 6, 7] # expect 4 ex = BFPRT() ck = Check() max_length, max_value = 100, 100 start = time.time() for i in range(10000): nums = ck.generate_nums(max_length, max_value) for i in range(len(nums)): res = ex.bfprt(nums, i+1) check_res = sorted(nums)[i] if res != check_res: print('oops, {}, {}, {}, {}', nums, i+1, res, check_res) print(time.time()-start)if __name__ == \"__main__\": main()","link":"/2018/10/06/BFPRT/"},{"title":"使用Python实现并查集","text":"并查集主要有两个功能： 检测两个元素是否在同一个集合； 合并两个元素所在集合； 本次实现使用的优化方法为路径压缩。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# -*- coding=utf-8 -*-class UnionFind(): \"\"\"并查集实现 \"\"\" def __init__(self): self._fatherMap = dict() self._sizeMap = dict() def makeSets(self, nodes): \"\"\"利用可迭代对象初始化并查集 Args: nodes (iterable): 元素集合 \"\"\" self._fatherMap.clear() self._sizeMap.clear() for node in nodes: self._fatherMap[node] = node self._sizeMap[node] = 1 def findHead(self, node): \"\"\"找几何头，其中有一个对长链的集合的平整操作, 平整操作执行的频率其实还需要进一步规整 Raises: KeyError: 如果本身传入的node就是不在全集里的就直接抛错 \"\"\" if not self.isValidNode(node): raise KeyError('node not in set') father = self._fatherMap.get(node) if father != node: father = self.findHead(father) self._fatherMap[node] = father return father def findHeadNotIter(self, node): \"\"\"上面函数的非递归版 \"\"\" if not self.isValidNode(node): raise KeyError('node not in set') stack = [] father = self._fatherMap.get(node) while father != node: stack.append(node) while stack: temp = stack.pop() self._sizeMap[self._fatherMap[temp]] -= 1 self._fatherMap[temp] = father self._sizeMap[father] += 1 return father def isSameSet(self, n1, n2): \"\"\"检测两个元素是否在一个集合里 Args: n1 (nodeType): 元素 n2 (nodeType): 元素 Returns: bool: True or False \"\"\" return self.findHead(n1) == self.findHead(n2) def isValidNode(self, node): return node in self._fatherMap def union(self, n1, n2): \"\"\"合并两个元素所在集合，小的集合并入到大的集合里，目的还是不想让集合链路过长 \"\"\" if not n1 or not n2: raise KeyError('node not valid') if not self.isValidNode(n1) or not self.isValidNode(n2): raise KeyError('node not valid') head1 = self.findHead(n1) head2 = self.findHead(n2) if head1 != head2: size1 = self._sizeMap[head1] size2 = self._sizeMap[head2] if size1 &lt;= size2: self._sizeMap[self._fatherMap[head1]] -= 1 self._fatherMap[head1] = head2 self._sizeMap[head2] += size1 else: self._sizeMap[self._fatherMap[head2]] -= 1 self._fatherMap[head2] = head1 self._sizeMap[head1] += size2def main(): sets = [1, 2, 3, 4, 5, 6] ex = UnionFind() ex.makeSets(sets) print(ex._fatherMap) print(ex._sizeMap) ex.union(1, 2) ex.union(3, 4) print(ex._fatherMap) print(ex._sizeMap) ex.union(5, 1) print(ex._fatherMap) print(ex._sizeMap)if __name__ == \"__main__\": main()","link":"/2018/10/22/union-find/"},{"title":"二叉树遍历方式总结：递归，非递归，morris，层序","text":"二叉树节点定义：123456# _*_ coding: utf-8 _*_class Node(): def __init__(self, val): self.val oo= val self.left = None self.right = None morris遍历的普遍过程： 遍历到节点cur的时候： 如果cur节点没有左子树，cur指向cur的右孩子； 如果cur节点有左子树: 如果左子树的最右节点的右孩子是指向空的（第一次到达cur节点），那么将这个最右节点的右孩子设置为cur节点，然后cur指向cur的左孩子； 如果左子树的最右节点的右孩子是指向cur节点的（第二次到达cur节点），那么将这个最右节点的右孩子还原为空，然后cur指向cur的右孩子； 代码：123456789101112131415161718192021222324class MorrisTraverse(): \"\"\"morris神级遍历普通过程\"\"\" def morris_traverse(self, root): if root is None: return None cur = root most_right = None while cur: most_right = cur.left # 如果cur节点有左孩子 if most_right: # 找到cur节点左孩子的最右节点 while most_right.right and most_right.right != cur: most_right = most_right.right # 如果是第一次到达节点cur，将该节点左孩子的最后节点的右孩子指向cur if most_right.right is None: most_right.right = cur cur = cur.left continue # 如果是第二次到达节点cur，第一次到达时建立的连接断开 else: most_right.right = None cur = cur.right 遍历方法集合类递归实现前中后序遍历：1234567891011121314151617181920212223242526272829class Traverse(): \"\"\"二叉树遍历方法类\"\"\" # 前序 def preorder_traverse(self, root): if root is None: return None # 第一次遍历到就打印 print(root.val, end=' ') self.preorder_traverse(root.left) self.preorder_traverse(root.right) # 中序 def inorder_traverse(self, root): if root is None: return None self.inorder_traverse(root.left) # 第二次遍历到就打印 print(root.val, end=' ') self.inorder_traverse(root.right) # 后序 def postorder_traverse(self, root): if root is None: return None self.postorder_traverse(root.left) self.postorder_traverse(root.right) # 第三次遍历到打印 print(root.val, end=' ') 非递归实现前中后序遍历：前序： 前序非递归也是最简单的，因为第一次就打印所以只需要按序遍历就好了。过程可总结如下： 压栈过程：首先压入根节点, 对于pop出的节点，如果有左孩子就入栈，如果有右孩子也入栈；； 出栈过程：pop一个节点，然后执行压栈过程； 12345678910111213141516def preorder_traverse_with_stack(self, root): if root is None: return None stack = [] stack.append(root) while stack: node = stack.pop() print(node.val, end=' ') # 先压入右孩子 if node.right: stack.append(node.right) # 再压入左孩子 if node.left: stack.append(node.left) print('') 中序： 中序非递归，因为中序是第二次访问到该节点的时候才打印，所以过程可以总结如下： 压栈过程：第一次访问到该节点压栈，然后再去找该节点的左孩子压栈； 出栈过程：当前无节点可压栈（已经到了最左的叶子节点), pop一个节点并打印，如果pop的节点有右孩子，那么重复压栈过程。 1234567891011121314151617def inorder_traverse_with_stack(self, root): \"\"\" 非递归中序遍历与前序遍历相比其实就是多了一个给每个节点找左孩子然后压栈的过程。 \"\"\" if root is None: return None stack = [] while stack or root: if root: stack.append(root) root = root.left else: root = stack.pop() print(root.val, end=' ') root = root.right print('') 后序： 后序非递归有两种经典方法： 使用两个栈： 由于我们知道前序遍历顺序是中左右，所以如果我们改写前序成中右左，然后把前序序列压栈，再弹出的顺序就是左右中，也就是后序遍历； 使用一个栈： 使用一个栈要注意弹出的节点的右节点是否在栈内，如果在栈内的话，要把右节点也弹出并且打印，然后再把第一次弹出的节点压栈，去找弹出的右节点有没有右节点，有的话就压栈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def post_traverse_with_two_stack(self, root): \"\"\" 这里用了一个取巧的方法，因为前序遍历是中左右，所以如果我们可以实现中右左的遍历，然后把遍历过程压入备用栈，然后从备用栈弹出的顺序就变成了左右中，也就是后序遍历。 \"\"\" if root is None: return None stack = [] stack_temp = [] stack.append(root) while stack: node = stack.pop() stack_temp.append(node) if node.left: stack.append(node.left) if node.right: stack.append(node.right) while stack_temp: print(stack_temp.pop().val, end=' ') print('')def post_traverse_with_one_stack(self, root): \"\"\" 只用一个栈的后序遍历。 1. 要判断弹出的节点，有没有右节点，有的话，压入右节点，再压入该节点 2. 要注意pop两次时的条件 **其实后序遍历就是逆序打印各子树右边界的过程，这个思想就用在morris逆序遍历上** \"\"\" if root is None: return None stack = [] while stack or root: while root: if root.right: stack.append(root.right) stack.append(root) root = root.left node = stack.pop() if stack and node.right and node.right == stack[-1]: root = stack.pop() stack.append(node) else: print(node.val, end=' ') root = None print('') 后来对单栈后序遍历做了一些小总结： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- coding=utf-8 -*-class TreeNode(): def __init__(self, val): self.val = val self.left = None self.right = Noneclass PostTraversal(): def post_traversal_1(self, root): # 先加根节点 后加右子节点 if root is None: return None stack = [] help_dict = {} while stack or root: while root: stack.append(root) if root.right: stack.append(root.right) root = root.left node = stack.pop() has_pass = help_dict.get(node, False) # 如果弹出节点为叶子节点，那么打印 if not node.left and not node.right: print(node.val, end=' ') # 如果弹出节点不是叶子节点，且弹出节点是父节点的右子节点 # 且没有进行过该节点的压栈过程 # 那么继续while中的压栈过程 elif stack and stack[-1].right == node and not has_pass: root = node help_dict[node] = True # 其他不应该重复压栈的节点 else: print(node.val, end=' ') print('') def post_traversal_2(self, root): if root is None: return None stack = [] while stack or root: while root: if root.right: stack.append(root.right) stack.append(root) root = root.left node = stack.pop() # 下面这个交换顺序的过程其实解决了上面那个解决方法中无法处理多次重复到达一个节点 # 并重复进行该节点的压栈过程的问题 if stack and node.right == stack[-1]: root = stack.pop() stack.append(node) else: print(node.val, end=' ') print('')if __name__ == \"__main__\": # 完全二叉树: The answer is 4 5 2 3 1. root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # 只有左子树: The answer is 3 2 1. root1 = TreeNode(1) root1.left = TreeNode(2) root1.left.left = TreeNode(3) # 只有右子树: The answer is 3 2 1. root2 = TreeNode(1) root2.right = TreeNode(2) root2.right.right = TreeNode(3) # 普通二叉树: The answer is 6 3 2 5 4 1. root3 = TreeNode(1) root3.left = TreeNode(2) root3.left.left = TreeNode(3) root3.left.left.right = TreeNode(6) root3.right = TreeNode(4) root3.right.right = TreeNode(5) tree = [root, root1, root2, root3] ex = PostTraversal() for root in tree: ex.post_traversal_1(root) ex.post_traversal_2(root) 借用morris遍历实现前中后序遍历 morris序中，如果一个节点有左子树，那么这个节点会访问两次，如果一个节点没有左子树，那么这个节点只会访问到一次； 前序： 借用morris序，在第一次访问该节点的时候就打印，就是前序序列； 12345678910111213141516171819202122232425def morris_pre_traverse(self, root): if root is None: return None cur = root most_right = None while cur: most_right = cur.left if most_right: while most_right.right and most_right.right != cur: most_right = most_right.right if most_right.right is None: most_right.right = cur # 第一次到达即打印 print(cur.val, end=' ') cur = cur.left continue else: most_right.right = None else: # 没有左子树的只会到达一次 print(cur.val, end=' ') cur = cur.right print('') 中序： 借用morris序，如果一个节点有左子树，第二次访问到时打印，如果一个节点没有左子树，那么第一次访问到时就打印。 123456789101112131415161718192021def morris_in_traverse(self, root): if root is None: return None cur = root most_right = None while cur: most_right = cur.left if most_right: while most_right.right and most_right.right != cur: most_right = most_right.right if most_right.right is None: most_right.right = cur cur = cur.left continue else: most_right.right = None # 没有左子树的第一次到达或者有左子树的第二次到达才打印 print(cur.val, end=' ') cur = cur.right print(' ') 后序： morris序最多只能到达一个节点两次，而后序遍历是第三次访问到一个节点时才打印，所以需要借助于一点儿小技巧。 1234567891011121314151617181920212223242526272829303132333435363738394041def morris_post_traverse(self, root): if root is None: return None cur = root most_right = None while cur: most_right = cur.left if most_right: while most_right.right and most_right.right != cur: most_right = most_right.right if most_right.right is None: most_right.right = cur cur = cur.left continue else: most_right.right = None # 在第二次到达时逆序打印cur节点的左子树的右边界 self.print_edge(cur.left) cur = cur.right # 逆序打印整个二叉树的右边界 self.print_edge(root) print('')def print_edge(self, node): tail = self.reverse_edge(node) temp = tail while temp: print(temp.val, end=' ') temp = temp.right self.reverse_edge(tail)def reverse_edge(self, node): pre = None while node: next_node = node.right node.right = pre pre = node node = next_node return pre 测试前中后序遍历正确性123456789101112131415161718192021222324252627282930313233343536373839404142434445def main(): # 完全二叉树 n1 = Node(1) n1.left = Node(2) n1.right = Node(3) n1.left.left = Node(4) n1.left.right = Node(5) n1.right.left = Node(6) n1.right.right = Node(7) # 只有左子树 n2 = Node(1) n2.left = Node(2) n2.left.left = Node(3) n2.left.left.left = Node(4) # 只有右子树 n3 = Node(1) n3.right = Node(2) n3.right.right = Node(3) n3.right.right.right = Node(4) ex = Traverse() for item in [n1, n2, n3]: ex.preorder_traverse(item) print('') ex.preorder_traverse_with_stack(item) ex.morris_pre_traverse(item) print('*' * 20) ex.inorder_traverse(item) print('') ex.inorder_traverse_with_stack(item) ex.morris_in_traverse(item) print('*' * 20) ex.postorder_traverse(item) print('') ex.post_traverse_with_one_stack(item) ex.post_traverse_with_two_stack(item) ex.morris_post_traverse(item) print('_' * 20)if __name__ == '__main__': main() 层次遍历：1234567891011121314151617def level_trans(root): if root is None: return None de = deque() de.appendleft(root) while de: loop = len(de) while loop &gt; 0: root = de.pop() print(root.val, end=' ') if root.left: de.appendleft(root.left) if root.right: de.appendleft(root.right) loop -= 1 print('') 变种层次遍历，打印从一颗二叉树左边看过去能看见的节点: 123456789101112131415161718192021def print_mostleft_node(root): if root is None: return None de = deque() de.appendleft(root) flag = True while de: loop = len(de) while loop &gt; 0: root = de.pop() if flag: print(root.val, end=' ') flag = False if root.left: de.appendleft(root.left) if root.right: de.appendleft(root.right) loop -= 1 print('') flag = True 其实就是打印每层第一个节点。","link":"/2018/08/14/summary-of-tranverse-methods-of-bt/"},{"title":"单调栈题总结","text":"1. 单调栈求解的基本问题： 给定一个数组，求数组中每个元素左右两边离其最近的元素，要求时间复杂度O(n)。 分析： 基本解法为对每一个元素，我们都遍历该元素两边的元素，然后都返回第一个比其小的元素。这样时间复杂度明显为O(n*n)。如果要满足时间复杂度要求，我们就要借助于单调栈来实现。 单调栈思想： 栈中元素只能是单调的。 对于上题我们可以建立一个从底至顶递增的单调栈。在遍历数组元素的时候:&emsp;&emsp;1.如果栈不为空，且当前遍历到的元素小于栈顶元素，就把栈顶元素抛出直到栈为空或者栈顶元素小于当前遍历到的元素，然后把当前遍历到的元素压栈；&emsp;&emsp;2.如果栈为空，且当前遍历到的元素大于栈顶元素，那么就直接把当前遍历到的元素压栈；数组遍历完之后，如果栈不为空：&emsp;&emsp;从栈中抛出元素，此时从栈中抛出的元素右边没有比其小的值； 代码：123456789101112131415161718192021222324252627282930313233def monotone_stack(arr): \"\"\"基础单调栈实现：求数组里每个元素左右离其最近的小于它的值； Arguments: arr {[list]} -- [输入数组] Returns: [list] -- [数组元素为列表，包含原数组对应下标值得左右最小值] \"\"\" if arr is None or len(arr) &lt; 1: return None res = {} stack = [] for i in range(len(arr)): while stack and arr[i] &lt; arr[stack[-1][0]]: item = stack.pop() for _ in item: res[_] = [arr[stack[-1][0]], arr[i] ] if stack else [None, arr[i]] if stack and arr[i] == arr[stack[-1][0]]: stack[-1].append(i) else: stack.append([i]) while stack: item = stack.pop() for _ in item: res[_] = [arr[stack[-1][0]], None] if stack else [None, None] return res 2. 求最大子矩阵的大小题意： 给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。例如：1 1 1 1其中，最大的矩形区域有3个1，所以返回3。再如：1 0 1 11 1 1 11 1 1 0其中，最大的矩形区域有6个1，所以返回6。 分析： 单调栈相关的问题，有些时候就好像在拿着一把竖直的尺子从中间往两边扩，扩到规则限定的边界。比如在题1中就是扩到两边离它最近的比它小的值所在的地方。对于这个题，如果我们把结果要的小矩形的数量，转换为矩形的面积。那么就可以做到如下图的转化： 那么把以每一行为底得到的数组看做一个直方图数组，我们就可以利用单调栈求得每个直方图数组上能联通的最大矩形面积。大概过程如下： 代码：1234567891011121314151617181920212223242526272829303132def get_max_submatrix(matrix): \"\"\"得到矩阵中元素都为1的矩形区域包含的最大元素个数 Arguments: matrix {list} -- 矩阵数组 Returns: int -- 最大区域元素个数 \"\"\" mat = copy.deepcopy(matrix) for i in range(len(mat)-1): for j in range(len(mat[0])): mat[i+1][j] = mat[i][j] + mat[i+1][j] if mat[i+1][j] != 0 else 0 max_area = 0 for arr in mat: stack = [] for _ in range(len(arr)): while stack and arr[_] &lt;= arr[stack[-1]]: item = arr[stack.pop()] cur_area = item * (_ - stack[-1] - 1) if stack else item * _ max_area = max(max_area, cur_area) stack.append(_) while stack: item = arr[stack.pop()] cur_area = item * \\ (len(arr) - stack[-1] - 1) if stack else item * len(arr) max_area = max(max_area, cur_area) return max_area 3. 烽火台题目： 战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都处于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。一旦发生外敌入侵事件，山顶上的岗哨将点燃烽烟。若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。输入: 输入中有多组测试数据。每组测试数据的第一行为一个整数n（3 &lt;=n &lt;= 10^6），为首都周围的小山数量，第二行为n个整数，依次表示小山的高度h，（1 &lt;= h &lt;= 10^9）。输出: 对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。样例输入：1251 2 4 5 3 样例输出：17 分析： &emsp;&emsp;1.对于所给数组元素不重复的情况：&emsp;&emsp;&emsp;&emsp;除了数组中的最大以及次大元素，其他每个元素都有两个可以瞭望到的烽火台；在最大以及次大之间可以互相瞭望，所以总共的可以相互观察的岗哨是(n-2)*2 + 1。&emsp;&emsp;2.对于所给数组有重复值的情况：&emsp;&emsp;&emsp;&emsp;此时不能在套公式了。我们现在首先确定我们遍历数组的原则是从小找大。这个时候就可以借助单调栈了，所不同的是我们这次是要找离当前遍历到的元素最近的比它大的元素位置。&emsp;&emsp;3.对于重复值的处理请看代码； 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def get_next_index(cur_index, arr): \"\"\"得到循环数组arr给定下标cur_index的下一个下标 Arguments: cur_index {int} -- 当前下标 arr {list} -- 给定循环数组 Returns: int -- 下一个遍历到的下标值 \"\"\" return 0 if cur_index == len(arr) - 1 else cur_index + 1def get_inter_pairs(n): \"\"\"得到中间没有更高山峰的相等高度山峰之间可互相瞭望的对数，即C(n, 2) Arguments: n {int} -- 中间没有更高山峰的相等高度山峰数目 Returns: int -- 可互相瞭望的山峰对 \"\"\" return 0 if n == 1 else (n * (n - 1)) // 2def get_watch_tower_pairs(arr): \"\"\"得到环形山中可互相瞭望的山峰对数目 Arguments: arr {list} -- 环形山峰高度数组 Returns: int -- 山峰对数目 \"\"\" if arr is None or len(arr) &lt; 2: return 0 if len(set(arr)) == len(arr): return (len(arr) - 2) * 2 + 1 res = 0 stack = [] cur_index = max_index = arr.index(max(arr)) for i in range(len(arr)): while stack and arr[cur_index] &gt; stack[-1][0]: item = stack.pop() res += get_inter_pairs(item[-1]) + item[-1] * 2 if stack and arr[cur_index] == stack[-1][0]: stack[-1][-1] += 1 else: stack.append([arr[cur_index], 1]) cur_index = get_next_index(cur_index, arr) while stack: item = stack.pop() res += get_inter_pairs(item[-1]) if stack: res += item[-1] if len(stack) &gt; 1: res += item[-1] else: res = res + item[-1] if stack[-1][-1] &gt; 1 else res return res 代码测试:1234567891011121314if __name__ == \"__main__\": arr1 = [3, 2, 1, 1, 6, 3, 7] arr2 = [1, 2, 4, 5, 3] mat = [[1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0], ] for arr in [arr1, arr2]: print(\"数组 {} 单调栈结果：\\n{}\".format(arr, sorted( monotone_stack(arr).items(), key=lambda x: x[0]))) print('') for arr in [arr1, arr2]: print(\"环形山数组 {} 有 {} 对可互望岗哨。\".format(arr, get_watch_tower_pairs(arr))) print('') print(\"矩阵 {} 里最大含1子矩阵个数是：{}\".format(mat, get_max_submatrix(mat))) output:12345678ne, 2]), (1, [None, 1]), (2, [None, None]), (3, [None, None]), (4, [1, 3]), (5, [1, None]), (6, [3, None])]数组 [1, 2, 4, 5, 3] 单调栈结果：[(0, [None, None]), (1, [1, None]), (2, [2, 3]), (3, [4, 3]), (4, [2, None])]环形山数组 [3, 2, 1, 1, 6, 3, 7] 有 12 对可互望岗哨。环形山数组 [1, 2, 4, 5, 3] 有 7 对可互望岗哨。矩阵 [[1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]] 里最大含1子矩阵个数是：6","link":"/2018/08/16/summary-of-monotous-stack-questions/"},{"title":"排序总结","text":"对数器： 对数器用来检测自定义排序算法是否正确。以下排序算法都经过10万个随机数组测试。 123456789101112131415import randomclass Comparator(): def compare(self, arr): return sorted(arr) def generate_arr(self, max_length, max_value): length = random.randint(0, max_length) arr = [random.randint(-max_value, max_value) for i in range(length)] return arr def confirm(self, arr1, arr2): return arr1 == arr2 1. 堆排序下面这个堆排序写复杂了！！！！，堆还有一个性质是可以利用的：当用数组表示存储n个元素的堆时，叶节点下标分别是[n//2, n//2+1, …, n-1]，这样的话我们构建堆的时候只要自下往上对不是叶节点的坐标执行heapify操作就可以了。 堆是一个极其重要的数据结构，堆排序主要是利用了堆的思想,其时间复杂度为O(N*logN),额外空间复杂度为O(1)。&emsp;&emsp;1.将数组调整成大根堆：&emsp;&emsp;&emsp;&emsp;在数组中，如果我们把index i位置的数字看作是根节点，那么它的左子节点在index (2 * i) + 1位置，右子节点在index (2 * i) + 2位置。反之index i位置的节点的父节点的位置在(i - 1) // 2位置。遍历数组添加元素，对每个新添加的元素执行heap_insert操作，从加入点开始上浮，直到上浮到合适位置；&emsp;&emsp;2.将大根堆顶与数组中最后一个元素交换，然后在不包括最后一个元素的数组区间执行heapify操作&emsp;&emsp;&emsp;&emsp;在堆顶与数组中最后一个元素交换后，我们需要重新调整堆，使得堆顶最大；&emsp;&emsp;3.重复2，直到可执行区间为1 代码：123456789101112131415161718192021222324252627282930313233343536373839404142class HeapSort(): def heapsort(self, arr): if arr is None or len(arr) &lt; 2: return arr length = len(arr) for i in range(length): self.heap_insert(arr, i) self.swap(arr, 0, length - 1) size = length - 2 while size &gt; 0: self.heapify(arr, 0, size) self.swap(arr, 0, size) size -= 1 def heap_insert(self, arr, i): while i &gt; 0: parent = (i - 1) // 2 if arr[parent] &gt; arr[i]: break else: self.swap(arr, parent, i) i = parent def heapify(self, arr, i, size): left = 2 * i + 1 while left &lt;= size: right = 2 * i + 2 largest = right if right &lt;= size and arr[right] &gt;= arr[left] else left largest = largest if arr[largest] &gt;= arr[i] else i if largest == i: break self.swap(arr, largest, i) i = largest left = 2 * i + 1 def swap(self, arr, i, j): arr[i], arr[j] = arr[j], arr[i] 下面是严格根据算法导论实现的堆排序，其中max_heapify的过程写了递归和非递归两个版本，实测排序10万个随机数组，非递归版本和递归版本分别需要24秒和27秒。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding=utf-8 -*-import timeclass HeapSort(): def heapsort(self, arr): if arr is None or len(arr) &lt; 2: return arr self._size = self._length = len(arr) self.build_max_heap(arr) for i in range(self._length-1, 0, -1): self.swap(arr, i, 0) self._size -= 1 self.max_heapify(arr, 0) def build_max_heap(self, arr): for i in range(self._length//2-1, -1, -1): self.max_heapify(arr, i) def max_heapify(self, arr, i): left = 2 * i + 1 while left &lt; self._size: right = 2 * i + 2 largest = right if right &lt; self._size and arr[right] &gt;= arr[left] else left largest = largest if arr[largest] &gt;= arr[i] else i if largest == i: break self.swap(arr, largest, i) i = largest left = 2 * i + 1 def max_heapify_recur(self, arr, i): left = 2 * i + 1 right = 2 * i + 2 if left &lt; self._size and arr[left] &gt; arr[i]: largest = left else: largest = i if right &lt; self._size and arr[right] &gt; arr[largest]: largest = right if largest != i: self.swap(arr, largest, i) self.max_heapify_recur(arr, largest) def swap(self, arr, i, j): arr[i], arr[j] = arr[j], arr[i]if __name__ == \"__main__\": from comparator import Comparator com = Comparator() ex = HeapSort() start = time.time() for i in range(100000): arr = com.generate_arr(100, 100) arr1 = list(arr) ex.heapsort(arr1) arr2 = com.compare(arr) if not com.confirm(arr1, arr2): print('oops') print(arr, arr1, arr2) print(time.time()-start) 2. 快排 随机快排就是随机+partition的过程。partition过程其实就是荷兰国旗问题。 代码：123456789101112131415161718192021222324252627282930313233343536import randomclass QuickSort(): def quick_min(self, arr): if arr is None or len(arr) &lt; 2: return arr self.quick_sort(arr, 0, len(arr) - 1) def quick_sort(self, arr, l, r): if l &lt; r: self.swap(arr, random.randint(l, r), r) left, right = self.partation(arr, l, r) self.quick_sort(arr, l, left) self.quick_sort(arr, right, r) def partation(self, arr, l, r): left = l - 1 right = r while l &lt; right: if arr[l] &lt; arr[r]: left += 1 self.swap(arr, l, left) l += 1 elif arr[l] == arr[r]: l += 1 else: right -= 1 self.swap(arr, l, right) self.swap(arr, right, r) return left, right + 1 def swap(self, arr, i, j): arr[i], arr[j] = arr[j], arr[i] 3. 归并代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import timeclass MergeSort(): def merge_main(self, nums): length = len(nums) if length &lt;= 1: return nums start = 0 end = length - 1 self.merge_sort_recur(nums, start, end) def merge_sort(self, nums): length = len(nums) if length &lt;= 1: return nums i = 1 while i &lt; length: start = 0 while start &lt; length: middle = start + i - 1 end = min(start + 2 * i - 1, length - 1) if middle &lt; end: self.merge(nums, start, end, middle) start += 2 * i i *= 2 def merge_sort_recur(self, nums, start, end): if start == end: return middle = start + ((end - start) &gt;&gt; 1) self.merge_sort_recur(nums, start, middle) self.merge_sort_recur(nums, middle+1, end) self.merge(nums, start, end, middle) def merge(self, nums, start, end, middle): cur_left = start cur_right = middle + 1 temp_list = [] while cur_left &lt;= middle and cur_right &lt;= end: if nums[cur_left] &lt;= nums[cur_right]: temp_list.append(nums[cur_left]) cur_left += 1 else: temp_list.append(nums[cur_right]) cur_right += 1 while cur_left &lt;= middle: temp_list.append(nums[cur_left]) cur_left += 1 while cur_right &lt;= end: temp_list.append(nums[cur_right]) cur_right += 1 for i in range(start, end+1): nums[i] = temp_list[i - start]def main(): from comparator import Comparator com = Comparator() ex = MergeSort() start = time.time() for i in range(100000): arr = com.generate_arr(100, 100) arr1 = list(arr) ex.merge_sort(arr) arr2 = com.compare(arr1) if not com.confirm(arr, arr2): print('oops') print(arr1, arr, arr2) print(time.time()-start) for i in range(100000): arr = com.generate_arr(100, 100) arr1 = list(arr) ex.merge_main(arr) arr2 = com.compare(arr1) if not com.confirm(arr, arr2): print('oops') print(arr1, arr, arr2) print(time.time()-start)if __name__ == '__main__': main() output: 1221.8536720275878942.81224775314331 可以看出非递归版还是快啊，10万个最大长度为100的数组，时间差达到非递归用时了。。","link":"/2018/08/19/summary-of-sort/"},{"title":"剑指offer 第三章 题16-26题解 Python版","text":"Github 代码完整性 基础功能； 输入边界值； 错误处理； 题16：数值的整数次方 此题不需要考虑大数问题，仅仅是计算整数次方，所以处理好特殊值就行了。 1234567891011121314151617181920212223242526272829303132333435class Solution: def Power(self, base, exponent): \"\"\"计算base的exponent次方 Arguments: base {int} -- 整数 exponent {int} -- 指数，可正可负 Returns: int -- 结果 \"\"\" if base == 0: return 0 if base == 1: return 1 abs_exponent = self.abs_exp(base, abs(exponent)) if exponent &gt; 0: return abs_exponent else: return 1 / abs_exponent # 此处处理有个窍门，可以二分计算 def abs_exp(self, base, exponent): if exponent == 0: return 1 if exponent == 1: return base res = self.abs_exp(base, exponent &gt;&gt; 1) res *= res if exponent &amp; 1 == 1: res *= base return res 题17：打印从1到最大的n位数 此题其实是想考察大数的处理，在python中，大数的影响几乎不存在，所以可以直接写。但是使用数组或者字符串表示大数的方式还是值得学一学。 123456789def print_1_to_n(n): if n &lt; 1: return i = 1 while len(str(i)) &lt;= n: print(i) i += 1 print(' ') 题18：删除链表的节点题19：正则表达式匹配 这个题情况分析很复杂。因为*可以表示出现任意次，所以在pattern中出现*时，s的推进情况就很复杂，此时用递归获取结果是最容易想明白的。 以模式的第二个字符为判断标准，来构造递归，具体看代码。 12345678910111213141516171819202122232425262728293031323334353637class Solution: # s, pattern都是字符串 def match(self, s, pattern): if len(s) == 0 and len(pattern) == 0: return True # 如果s长度不为0，而pattern长度为0，这种情况不可能匹配成功 elif len(s) != 0 and len(pattern) == 0: return False # 如果s长度为0， 而pattern长度不为0，那么可能会有pattern为'（.*）*'的情况 elif len(s) == 0 and len(pattern) != 0: # 如果pattern第二位为0, pattern推进两个 if len(pattern) &gt; 1 and pattern[1] == '*': return self.match(s, pattern[2:]) else: return False # 如果s和pattern长度都不为0 else: # pattern第二位为* if len(pattern) &gt; 1 and pattern[1] == '*': # 如果s[0] != pattern[0] if s[0] != pattern[0] and pattern[0] != '.': return self.match(s, pattern[2:]) # 如果s[0] == pattern[0], 那么有三种情况 # 1. s不变，pattern后移两步（pattern前两个字符等价于空） # 2. s右移一个， pattern右移两个 （pattern前两个字符等价于一个字符） # 3. s右移一个， pattern不右移 （pattern前两个字符等价于多个字符)） else: return self.match(s, pattern[2:]) or \\ self.match(s[1:], pattern[2:]) or \\ self.match(s[1:], pattern) # pattern第二位不是* else: # 比较第一位的情况 if s[0] == pattern[0] or pattern[0] == '.': return self.match(s[1:], pattern[1:]) else: return False 这个题是真的烦。。 题20：表示数值的字符串 这个题并没有什么意思，找到所有可有可无的片段凑正则就行了。 123456import reclass Solution: # s字符串 def isNumeric(self, s): return True if re.match(r\"^[\\+\\-]?[0-9]*(\\.[0-9]*)?([eE][\\+\\-]?[0-9]+)?$\", s) else False 题21：调整数组顺序使奇数位于偶数前面 这个题可以借助荷兰国旗问题求解。 1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): if array is None or len(array) &lt; 2: return array p1 = 0 p2 = len(array) - 1 while p1 &lt; p2: if self.is_even(array[p1]) and not self.is_even(array[p2]): self.swap(array, p1, p2) while not self.is_even(array[p1]): p1 += 1 while self.is_even(array[p2]): p2 -= 1 def is_even(self, item): return item &amp; 1 == 0 def swap(self, array, i, j): array[i], array[j] = array[j], array[i] 如果要求保留原数组奇数间的顺序以及偶数间的顺序，借助了辅助数组的代码如下: 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def is_even(self, item): return item &amp; 1 == 0 def reOrderArray(self, array): if array is None or len(array) &lt; 2: return array assi_array = [] for item in array: if not self.is_even(item): assi_array.append(item) for item in array: if self.is_even(item): assi_array.append(item) return assi_array 代码鲁棒性 判断输入 容错性 题22：链表中倒数第k个节点题目： 输入一个链表，输出该链表中倒数第k个节点。本题从1开始计数，即尾节点为倒数第1个节点。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def FindKthToTail(self, head, k): \"\"\"打印链表倒数第k个节点 Args: head (ListNode): 链表头结点 k (int): 指定数字 Returns: ListNode: 倒数第k个节点 \"\"\" p_ahead = head p_behind = head while k &gt; 0: if p_ahead is None: return None p_ahead = p_ahead.next k -= 1 while p_ahead is not None: p_ahead = p_ahead.next p_behind = p_behind.next return p_behind 题23：链表中环的入口节点题目： 如果一个链表中包含环，如何找出环的入口节点？ 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def EntryNodeOfLoop(self, pHead): \"\"\"找到链表中环的入口节点 Args: pHead (ListNode): 链表头结点 Returns: ListNode: 入口节点（如果没有返回None） \"\"\" if pHead is None or pHead.next is None: return None p1 = p2 = pHead while p2.next is not None: p2 = p2.next.next p1 = p1.next if p1 == p2: first_met = p1 count = 1 while p1.next != first_met: p1 = p1.next count += 1 p1 = p2 = pHead for i in range(count): p1 = p1.next while p1 != p2: p1 = p1.next p2 = p2.next return p1 return None 题24：反转链表题目： 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def ReverseList(self, pHead): \"\"\"反转链表，返回反转后的头 Args: pHead (ListNode): 链表头 Returns: ListNode: 反转之后链表头 \"\"\" if pHead is None or pHead.next is None: return pHead new_head = self.ReverseList(pHead.next) pHead.next.next = pHead pHead.next = None return new_head 题25：合并两个排序的链表题目： 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def Merge(self, pHead1, pHead2): \"\"\"合并两个排序链表 \"\"\" if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 p1, p2 = pHead1, pHead2 merge_head = None if p1.val &lt; p2.val: merge_head = p1 merge_head.next = self.Merge(p1.next, p2) else: merge_head = p2 merge_head.next = self.Merge(p1, p2.next) return merge_head","link":"/2018/08/20/offer16-26/"},{"title":"PEP 3333 -- Python Web Server Gateway Interface 阅读笔记[to be continued]","text":"前言PEP 3333 是PEP 333的更新，对于原来和PEP 333兼容的应用和服务器，它们和PEP 3333仍然是兼容的。 对于Python3来说，编写应用或者服务器必须要遵循下面两个标题命名的版块里提到的规则：A Note On String Types,和Unicode Issues。 摘要如果有人问你WSGI是啥，就可以参考下面这句话回答他了：“This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application protability across a variety of web servers. ” 出发点和目标（Original Rationale and Goals）出发点： Python目前有很多web应用程序框架，众多的选择给Python新用户带来一个问题：在选择web框架的同时，也限制了他们对于可用的web服务器的选择，反过来也是一样。 作为比较，Java也有很多的web应用框架，但是Java的servletAPI可以让任何Java web应用框架在支持这种API的web服务器上运行。 所以，Python实现一个这种API也是有必要的。 目标： 1.&emsp;鉴于现在还没有支持WSGI的服务器或者框架，所以WSGI必须容易实现，开发者的上手难度也要降到最小；需要注意的是，对于框架作者来说容易实现，并不意味着对web应用作者也是这样。所以WSGI没有添加花里胡哨的像返回对象和cookie处理这些可能会影响现有框架处理这些问题的东西，而是呈现了一个没有装饰的接口。WSGI的目标是能让现有服务器和应用或者框架之间更容易交流，而不是创建一个新的web框架。 还要注意的是，这个目标也阻止了WSGI使用任何在现发行的Python版本中没有的东西作为依赖。因此，本规范没有提出或要求新的标准库模块，而且WSGI中的任何内容都不需要大于2.2.2的Python版本。（不过，对于未来版本的Python来说，在标准库提供的web服务器中包含对该接口的支持将是一个好主意。） 2.&emsp;为了让现有的以及未来的框架和服务器更容易实现WSGI，WSGI也应该能很容易的创建请求预处理、响应后处理以及其它基于WSGI的middleware组件。 （文档里还yy了一下前景：）如果中间件足够简单且健壮，并且WSGI在服务器和框架中被广泛使用，那么就有可能出现一种全新的Python web应用程序框架：一个由松散耦合的WSGI中间件组件组成的框架。事实上，现有的框架作者甚至可能会选择重构他们的框架的现有服务，变得更像是和WSGI一起使用的库，而不像一个完整统一的框架。这可能会使得应用开发者可以去选择对于某一功能的最佳组合组件，而不是需要接受一整个框架的好处和坏处。 3.&emsp;最后应该提到，目前版本的WSGI没有对部署应用规定任何特殊机制。 规范综述（Specification Overview）WSGI接口包括两端：服务器或者网关端，和应用或者框架端。服务器端调用一个由应用端提供的可调用对象。 下面这两段话有点儿迷糊，先记录原话和当前理解： In addition to “pure” servers/gateways and applications/frameworks, it is also possible to create “middleware” components that implement both sides of this specification. Such components act as an application to their containing server, and as a server to a contained application, and can be used to provide extended APIs, content transformation, navigation, and other useful functions. 对包含它的服务器表现的像应用，对包含它的应用表现的像服务器。 Throughout this specification, we will use the term “a callable” to mean “a function, method, class, or an instance with a call method”. It is up to the server, gateway, or application implementing the callable to choose the appropriate implementation technique for their needs. Conversely, a server, gateway, or application that is invoking a callable must not have any dependency on what kind of callable was provided to it. Callables are only to be called, not introspected upon. 一个callable可以指一个函数，一个方法，一个类或者一个定义了__call__方法的实例。由实现the callable的服务器、网关或者应用程序根据它们的需要选择适当的实现技术。另一方面，调用callable的服务器、网关或应用程序禁止依赖提供给它的callable的类型。也就是说，callbles只是用来被调用的，而不是被内省（获取它们的类型）。 一个字符串类型需要注意的地方（A Note On String Types）通常，HTTP处理的是字节，这就意味着这个规范主要就是关于如何处理字节。 字节内容总会有某种文本解释（textual interpretation），在Python中，字符串是处理文本最方便的方式。 但是在很多Python版本和实现中，字符串是Unicode，而不是字节。这就需要在一个可用的API和在HTTP上下文的文本中正确的转换字节和文本之间进行谨慎的权衡。 也基于此，WSGI定义了两种”string”： “Native” strings（总是使用str类型实现。），用于请求/响应头和元数据。 “Bytestrings”（在Python3中使用bytes类型实现，在其他地方使用str类型实现），用于请求和响应的主体（比如POST/PUT输入数据和HTML页面的输出）。 但是不要搞混了：即使Python的str类型底层实际上Unicode，native strings的内容也必须能够通过Latin-1编码转换到字节。（细节参见下面的Unicode Issues章节）。 应用/框架端应用程序对象（application object）只是一个接受两个 参数的可调用对象。术语object不应该被误解为需要一个实际的对象实例：函数、方法、类或带有__calll__方法的实例都可以作为应用程序对象使用。应用程序对象必须能够被多次调用，因为几乎所有的服务器/网管（CGI除外）都会发出重复请求。 （注意：虽然我们把它叫做应用程序对象，但这不应该被解释为应用程序开发者会使用WSGI作为web编程的API。WSGI是一个面向框架和服务器开发者的工具，而没有直接支持应用程序开发者的倾向。） 下面是两个应用程序对象；一个是函数，另一个是类： 123456789101112131415161718192021222324252627282930313233HELLO_WORLD = b\"Hello world!\\n\"def simple_app(environ, start_response): \"\"\"Simplest possible application object\"\"\" status = '200 OK' response_headers = [('Content-type', 'text/plain')] start_response(status, response_headers) return [HELLO_WORLD]class AppClass: \"\"\"Produce the same output, but using a class (Note: 'AppClass' is the \"application\" here, so calling it returns an instance of 'AppClass', which is then the iterable return value of the \"application callable\" as required by the spec. If we wanted to use *instances* of 'AppClass' as application objects instead, we would have to implement a '__call__' method, which would be invoked to execute the application, and we would need to create an instance for use by the server or gateway. \"\"\" def __init__(self, environ, start_response): self.environ = environ self.start = start_response def __iter__(self): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield HELLO_WORLD 服务器/网关端服务器或者网关为每一个从HTTP接收到的请求调用一次请求调用一次该请求对应的可调用应用程序。下面是一个简单的CGI网关，一个接收应用程序对象的函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475mport os, sysenc, esc = sys.getfilesystemencoding(), 'surrogateescape'def unicode_to_wsgi(u): # Convert an environment variable to a WSGI \"bytes-as-unicode\" string return u.encode(enc, esc).decode('iso-8859-1')def wsgi_to_bytes(s): return s.encode('iso-8859-1')def run_with_cgi(application): environ = {k: unicode_to_wsgi(v) for k,v in os.environ.items()} environ['wsgi.input'] = sys.stdin.buffer environ['wsgi.errors'] = sys.stderr environ['wsgi.version'] = (1, 0) environ['wsgi.multithread'] = False environ['wsgi.multiprocess'] = True environ['wsgi.run_once'] = True if environ.get('HTTPS', 'off') in ('on', '1'): environ['wsgi.url_scheme'] = 'https' else: environ['wsgi.url_scheme'] = 'http' headers_set = [] headers_sent = [] def write(data): out = sys.stdout.buffer if not headers_set: raise AssertionError(\"write() before start_response()\") elif not headers_sent: # Before the first output, send the stored headers status, response_headers = headers_sent[:] = headers_set out.write(wsgi_to_bytes('Status: %s\\r\\n' % status)) for header in response_headers: out.write(wsgi_to_bytes('%s: %s\\r\\n' % header)) out.write(wsgi_to_bytes('\\r\\n')) out.write(data) out.flush() def start_response(status, response_headers, exc_info=None): if exc_info: try: if headers_sent: # Re-raise original exception if headers sent raise exc_info[1].with_traceback(exc_info[2]) finally: exc_info = None # avoid dangling circular ref elif headers_set: raise AssertionError(\"Headers already set!\") headers_set[:] = [status, response_headers] # Note: error checking on the headers should happen here, # *after* the headers are set. That way, if an error # occurs, start_response can only be re-called with # exc_info set. return write result = application(environ, start_response) try: for data in result: if data: # don't send headers until body appears write(data) if not headers_sent: write('') # send headers now if body was empty finally: if hasattr(result, 'close'): result.close() 中间件：左右逢源的组件（Middleware: Components that Play Both Sides）要注意的是，一个对象对于一些应用可能发挥服务器的作用，对于一些服务器，又可能表现得像应用。这种中间件组件能够执行以下功能： 根据目标URL，重写了对应environ之后，将一个请求路由到不同的应用程序对象 可以让多个应用或者框架在一个进程中并行运行 通过网络转发请求和响应，实现负载均衡和远程处理 执行内容后处理，比如应用XSL样式表 一般来说，中间件对于服务器/网关端和应用/框架端的接口都是透明的，而且不应该需要特殊支持。用户想要把中间件嵌入应用中只需要简单的把中间件提供给服务器，就好像中间件也是一个应用一样；而且（如果想要把中间件嵌入服务器）配置中间件组件调用应用程序，就好像中间件组件是一个服务器一样。当然，这个中间件包裹的应用实际上可能是另外一个包裹着另一个应用的中间件，以此类推，就创造出了被称为中间件栈的东西。 在很大程度上，中间件必须遵循服务器端和应用端的限制和需求。在一些情况下，中间件的要求要比一个单纯的服务器或者应用还要严格，这些情况会在规范中指出。 下面是一个很随意的例子，功能是将text/plain响应转换成pigLatin。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869m piglatin import piglatinclass LatinIter: \"\"\"Transform iterated output to piglatin, if it's okay to do so Note that the \"okayness\" can change until the application yields its first non-empty bytestring, so 'transform_ok' has to be a mutable truth value. \"\"\" def __init__(self, result, transform_ok): if hasattr(result, 'close'): self.close = result.close self._next = iter(result).__next__ self.transform_ok = transform_ok def __iter__(self): return self def __next__(self): if self.transform_ok: return piglatin(self._next()) # call must be byte-safe on Py3 else: return self._next()class Latinator: # by default, don't transform output transform = False def __init__(self, application): self.application = application def __call__(self, environ, start_response): transform_ok = [] def start_latin(status, response_headers, exc_info=None): # Reset ok flag, in case this is a repeat call del transform_ok[:] for name, value in response_headers: if name.lower() == 'content-type' and value == 'text/plain': transform_ok.append(True) # Strip content-length if present, else it'll be wrong response_headers = [(name, value) for name, value in response_headers if name.lower() != 'content-length' ] break write = start_response(status, response_headers, exc_info) if transform_ok: def write_latin(data): write(piglatin(data)) # call must be byte-safe on Py3 return write_latin else: return write return LatinIter(self.application(environ, start_latin), transform_ok)# Run foo_app under a Latinator's control, using the example CGI gatewayfrom foo_app import foo_apprun_with_cgi(Latinator(foo_app))","link":"/2018/09/11/reading-notes-of-PEP3333-WSGI/"},{"title":"剑指offer 第二章 题3-15题解 Python版","text":"Github 数组题3： 数组中的重复数字 在一个长度为n的数组里所有的数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数组。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的2或3. 解法： 可以用辅助hash表存放已经遍历到的元素，如果发现当前遍历到的元素已经在hash表中了，return； 如果不适用辅助数据结构,那么就要从数组本身特点出发： 数组所有数字在0~n-1范围内，如果我们把这个数组排序，如果没有重复元素，那么数字i就应该在索引位置为i的位置。如果有重复，那么必然一个数字会占据多个索引。 基于此，我们从头开始遍历，如果numbers[i] != i那么，就把i位置的元素和numbers[i]位置的元素交换（这样就有一个元素放到了如果不重复的情况下的正确位置），如果我们在交换的时候number[i]位置的元素就等于numbers[i]这说明，该数字出现了最少两次，我们得到了一个可能结果。 题4：二维数组中的查找题目： 一个二维数组，从左到右递增，从上到下递增，给定一个数，判断该数是否在数组里。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def Find(self, target, array): \"\"\"在一个从左到右递增，从上往下递增的数组中查找元素 Args: target (int): 待查找数字 array (list): 待查找数组 Returns: bool: 是否找到 \"\"\" row_length = len(array) col_length = len(array[0]) if row_length == 0 or col_length == 0: return False i, j = 0, col_length - 1 while True: if array[i][j] == target: return True elif array[i][j] &lt; target: if i &lt; row_length - 1: i += 1 else: return False else: if j &gt; 0: j -= 1 else: return False 字符串题5：替换空格题目： 实现一个函数，将字符串中每个空格替换成“%20”. 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def replaceSpace(self, s): \"\"\"将s中的空格替换成%20 Args: s (str): 给定字符串 Returns: str: 替换后字符串 \"\"\" blank_nums = s.count(' ') original_length = len(s) s = list(s) s.extend(['0' for i in range(2*blank_nums)]) i = original_length - 1 j = original_length + 2 * blank_nums - 1 while i &gt;= 0 and i &lt;= j: if s[i] == ' ': s[j-2:j+1] = '%20' j -= 3 i -= 1 else: s[j] = s[i] j -= 1 i -= 1 s = ''.join(s) return s 链表题6：从尾到头打印链表题目： 输入一个链表的头部，从尾到头打印每个节点的值 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def __init__(self): self.res = [] def printListFromTailToHead(self, listNode): \"\"\"从尾到头打印链表，将打印结果存入数组 Args: listNode (ListNode): 链表头 Returns: list: 数组结果 \"\"\" if listNode is not None: self.printListFromTailToHead(listNode.next) self.res.append(listNode.val) return self.res 树题7：重建二叉树题目： 给定一个二叉树的前序序列和中序序列，请重建该二叉树。 解法： 找树根，然后递归建立左右子树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: \"\"\"根据前序序列和中序序列重建二叉树 \"\"\" def reConstructBinaryTree(self, pre, tin): \"\"\"根据前序序列和中序序列重建二叉树 Args: pre (list): 前序遍历序列 tin (list): 中序遍历序列 Returns: TreeNode: 重建二叉树头 \"\"\" if len(pre) != len(tin) or len(pre) == 0 or len(tin) == 0: return None root = TreeNode(pre[0]) if pre[0] in tin: value = tin.index(pre[0]) else: return None left_tin, right_tin = tin[:value], tin[value+1:] left_pre, right_pre = pre[1:1+len(left_tin)], pre[1+len(left_tin):] root.left = self.reConstructBinaryTree(left_pre, left_tin) root.right = self.reConstructBinaryTree(right_pre, right_tin) return rootdef main(): pre = [1, 2, 3, 4, 5, 6, 7] tin = [3, 2, 4, 1, 6, 5, 7] ex = Solution() root = ex.reConstructBinaryTree(pre, tin) print(root.val, ' ', root.left.val, ' ', root.right.val)if __name__ == '__main__': main() 题8：二叉树的下一个节点题目： 给定一棵二叉树和其中一个节点，如何找出中序序列的下一个节点？树中的节点除了有两个分别指向左、右节点的指针，还有一个指向父节点的指针。 123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class TreeLinkNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = Noneclass Solution: def GetNext(self, pNode): \"\"\"查找给定节点的下一个节点 Args: pNode (TreeLinkNode): 给定二叉树头 Returns: TreeLinkNode: 给定节点的下一个节点，没有则是None \"\"\" if pNode.right: p = pNode.right while p.left: p = p.left return p elif pNode.next and pNode.next.left == pNode: return pNode.next elif pNode.next and pNode.next.right == pNode: p = pNode while p.next and p.next.next: if p.next.next.left == p.next: return p.next.next p = p.next return None else: return None 栈和队列题9：用两个栈实现队列题目： 用两个栈实现一个队列。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Stack: def __init__(self): self.data = [] def push(self, item): self.data.append(item) def pop(self): return self.data.pop() def is_empty(self): return False if len(self.data) else Trueclass Solution: def __init__(self): self.stack1 = Stack() self.stack2 = Stack() def push(self, node): self.stack1.push(node) def pop(self): if self.stack2.is_empty(): self.dao() return self.stack2.pop() def dao(self): while not self.stack1.is_empty(): self.stack2.push(self.stack1.pop()) 递归和循环题10： 斐波那契数列题目一：求斐波那契数列的第n项1234567891011# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): fib0, fib1 = 0, 1 if n &lt; 2: return n for i in range(2, n+1): fibi = fib0 + fib1 fib0 = fib1 fib1 = fibi return fibi 题目二：跳台阶问题123456789101112131415# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here fib1 = 1 fib2 = 2 if number == 1: return fib1 if number == 2: return fib2 for i in range(3, number+1): fibi = fib1 + fib2 fib1 = fib2 fib2 = fibi return fibi 题目三：变态跳台阶问题1234567# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): \"\"\"有时候我们只是缺少一个发现规律的眼睛 \"\"\" return 2 ** (number - 1) 查找和排序题11：旋转数组的最小数字题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组[3, 4, 5, 1, 2]为[1, 2, 3, 4, 5]的一个旋转，该数组的最小值为1. 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): \"\"\"找到旋转数组中的最小数字 Args: rotateArray (list): 数组 Returns: int: 最小数字 \"\"\" if rotateArray is None or len(rotateArray) &lt;= 0: return 0 low = mid = 0 high = len(rotateArray) - 1 while rotateArray[low] &gt;= rotateArray[high]: mid = (low + high) // 2 if rotateArray[low] == rotateArray[high] and rotateArray[low] == rotateArray[mid]: return self.sequential_compare(rotateArray, low, high) if rotateArray[mid] &gt;= rotateArray[low]: low = mid if rotateArray[mid] &lt;= rotateArray[high]: high = mid if high - low == 1: return rotateArray[high] return rotateArray[mid] def sequential_compare(self, rotateArray, low, high): if low == high: return rotateArray[low] for i in range(low, high+1): if rotateArray[i] &lt; rotateArray[low]: return rotateArray[i] return rotateArray[low] 回溯法：回溯法适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。当当前选项不满足条件时，我们就回退到上一步，选择其他选项。 题12：矩阵中的路径解法： 此题用回溯法解，如果发现矩阵当前节点能满足路径需要，但是当前节点周围的四个节点都不等于路径下一个值，那么就回退。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution: def hasPath(self, matrix, rows, cols, path): \"\"\"寻找字符矩阵中相邻元素是否可以组成给定的path Arguments: matrix {list} -- 字符矩阵 rows {int} -- 矩阵总行数 cols {int} -- 矩阵总列数 path {str} -- 给定字符串路径 Returns: bool -- 是否存在路径 \"\"\" if matrix is None or rows &lt; 1 or cols &lt; 1 or path is None: return False mem = [[False for i in range(cols)] for j in range(rows)] cur_path_length = 0 for row in range(rows): for col in range(cols): cur_path_length = 0 res = self.has_path(matrix, row, col, rows, cols, cur_path_length, path, mem) if res: return True return False def has_path(self, matrix, row, col, rows, cols, cur_path_length, path, mem): \"\"\"矩阵路径搜索函数 Arguments: matrix {list} -- 字符矩阵 row {int} -- 当前到达矩阵元素的行 col {int} -- 当前到达矩阵元素的列 rows {int} -- 矩阵总行数 cols {int} -- 矩阵总列数 cur_path_length {int} -- 当前已经确认存在的路径长度 path {str} -- 给定字符串路径 mem {list} -- 记录元素是否已经被访问过的矩阵 Returns: bool -- 返回row，col元素的邻居能不能继续匹配path \"\"\" if cur_path_length == len(path): return True inner_res = False if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and \\ matrix[row][col] == path[cur_path_length] and not mem[row][col]: cur_path_length += 1 mem[row][col] = True inner_res = self.has_path(matrix, row, col-1, rows, cols, cur_path_length, path, mem) or \\ self.has_path(matrix, row-1, col, rows, cols, cur_path_length, path, mem) or \\ self.has_path(matrix, row, col+1, rows, cols, cur_path_length, path, mem) or \\ self.has_path(matrix, row+1, col, rows, cols, cur_path_length, path, mem) if not inner_res: cur_path_length -= 1 mem[row][col] = False return inner_res 题13: 机器人的运动范围解法： 与题12类似，回溯法求解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution: def movingCount(self, threshold, rows, cols): \"\"\"主函数 Arguments: threshold {int} -- 阈值，当前访问的格子横纵坐标坐标各位数字加起来不应超过threshold rows {int} -- 矩阵总行数 cols {int} -- 矩阵总列数 Returns: int -- 可以访问的坐标数 \"\"\" if threshold &lt; 0 or rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False for i in range(rows * cols)] count = self.moving_count(threshold, rows, cols, 0, 0, visited) return count def moving_count(self, threshold, rows, cols, row, col, visited): \"\"\"递归计算可去做标数 Arguments: row {int} -- 当前横坐标 col {int} -- 当前纵坐标 visited {list} -- 记录当前坐标是否已经被计算过 Returns: [type] -- [description] \"\"\" count = 0 if self.check(threshold, rows, cols, row, col, visited): # 防止重复计算 visited[row * cols + col] = True count = 1 + self.moving_count(threshold, rows, cols, row, col-1, visited) \\ + self.moving_count(threshold, rows, cols, row-1, col, visited) \\ + self.moving_count(threshold, rows, cols, row, col+1, visited) \\ + self.moving_count(threshold, rows, cols, row+1, col, visited) return count def check(self, threshold, rows, cols, row, col, visited): \"\"\"判断该坐标是否可以访问 Returns: bool \"\"\" if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and \\ self.get_sum(row) + self.get_sum(col) &lt;= threshold and \\ not visited[row * cols + col]: return True return False def get_sum(self, num): total = 0 while num &gt; 0: total += num % 10 num //= 10 return total 回溯法总结：回溯法顾名思义最重要的是回溯，题12是最典型的回溯法，在该题中，只有当前节点的下一步走不通，我们是会把当前节点重新标记为未访问的，这样就“回退”了。但纵观这两个题，其实这就是一个递归，主要的还是对分支情况以及递归分支返回的处理。在回溯法中，只有条件符合，才会继续递归，要不然本次递归分支就直接被抛弃了。 动态规划如果题目是求最优解，且该题能够分解成若干个子问题，而且子问题还有重叠，这类题就适合用dp来解。dp从暴力递归中来，可以用dp解决的题目一般都能用暴力递归解决，但是由于子问题有重叠，所以用递归就会造成大量的重复计算，而dp就是要找到问题之间存在的规律，从小到大的解决问题。 题14: 剪绳子题目： 给你一根长度为n的绳子，请把绳子剪成m段，使得小段乘积最大。（n&gt;1, m&gt;1） 解法： f(n) = max(f(i) * f(n-i)) 1234567891011121314151617181920def cut_rope(n): if n &lt; 2: return 0 if n == 2: return 1 if n == 3: return 2 temp_arr = [0 for i in range(n+1)] pre = (0, 1, 2, 3) # f(1), f(2), f(3)作为别人切下的子过程的时候与自己本身返回时不同的 for i in range(len(pre)): temp_arr[i] = pre[i] for i in range(4, n+1): max_mul = 0 for j in range(1, i//2+1): max_mul = max(temp_arr[j] * temp_arr[i - j], max_mul) temp_arr[i] = max_mul return temp_arr[n] 需要注意的是，f(3)以及f(3)以下的绳子在剪自身和作为别的绳子的子段的时候返回值是不一样的。绳子长度为3，最少剪一刀应该返回2，但从更长的绳子上剪下的绳子长度为3的贡献值应该为3（而不是2.） 位运算位运算在某些情况下非常有用。比如利用异或可以求数组中唯一不重复元素，利用(n - 1）&amp; n可以将n中最后一个1清零，可以计算n中比特位为1的个数，可以判断n是不是2的整数次方等等； 题15：二进制中1的个数解法： 这道题有多种解法：&emsp;&emsp;1.把数字n和1做与运算，判断n的最低位是不是1，接着把1左移一位，判断n的次低位是不是1。重复这个过程，我们就能判断n中有多少位1；&emsp;&emsp;2.有一个小技巧：把一个整数减去1，然后再和原整数做与运算，会把该整数最右边的1变成0。那么整数里有几个1，我们就比较几次就得了。 12345678910111213141516171819# 解法1：def numer2(n): count = 0 flag = 1 while flag &lt;= 2 ** 31: if n &amp; flag: count += 1 flag = flag &lt;&lt; 1 print(flag, bin(flag)) return count# 解法2：from ctypes import *def (n): count = 0 while c_int(n).value: count += 1 n = (n - 1) &amp; n return count 注意：因为python里int是没有位数限制的，当int超过32位时，python会自动扩充，所以如果解法1中对flag不限制，while会无限循环下去直到溢出；解法2中如果不使用c_int做限制，那么对于n是负数的情况同样会无限循环到溢出。","link":"/2018/08/19/offer3-15/"},{"title":"剑指offer 第四章 题27-38题解 Python版","text":"Github 举例让抽象问题具体化 如果没有思路，那就尝试手推几个例子吧。 题27：二叉树的镜像题目： 请完成一个函数，输入一课二叉树，请函数输出它的镜像。 解法：镜像也就意味着每一个子树的左右节点都得互换，所以自然可以想到可以使用递归交换每个节点的左右子树就好了；顺手也写了个非递归版. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): if root is None: return stack = [] stack.append(root) while stack: temp = stack.pop() if temp.left is not None or temp.right is not None: temp.left, temp.right = temp.right, temp.left if temp.left is not None: stack.append(temp.left) if temp.right is not None: stack.append(temp.right) def Mirror_recur(self, root): \"\"\"递归版\"\"\" if root is None: return if root.left or root.right: root.left, root.right = root.right, root.left self.Mirror_recur(root.left) self.Mirror_recur(root.right) def mirror(self, root1, root2): \"\"\"检测两棵二叉树是不是镜像树 Args: root1 (TreeNode): 二叉树头结点 root2 (TreeNode): 二叉树头结点 Returns: bool: 是否为镜像树 \"\"\" if root1 is None and root2 is None: return True if root1 is None or root2 is None: return False if root1.val != root2.val: return False return self.mirror(root1.left, root2.right) and self.mirror(root1.right, root2.left)def main(): root = TreeNode(8) root.left = TreeNode(6) root.right = TreeNode(10) root.left.left = TreeNode(5) root.left.right = TreeNode(7) root.right.left = TreeNode(9) root.right.right = TreeNode(11) # 镜像树 root1 = TreeNode(8) root1.left = TreeNode(6) root1.right = TreeNode(10) root1.left.left = TreeNode(5) root1.left.right = TreeNode(7) root1.right.left = TreeNode(9) root1.right.right = TreeNode(11) ex = Solution() ex.Mirror(root) print(ex.mirror(root1, root))if __name__ == '__main__': main() 题28：对称的二叉树题目： 请实现一个函数，用来判断一课二叉树是不是对称的。如果一个二叉树和它的镜像一样，那么他就是对称的. 解法： 题意说的很清楚，可以通过判断二叉树和它的镜像是否相等来判断二叉树是否对象，或者换一种说法，检测二叉树和它自己是否是镜像才. 利用树的遍历，前序中左右，我们再写一个自定义序中右左，那么对于对称树，这两个遍历序是一样的，可以利用这个来确定是否是对称树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def is_symmetry_tree(self, root1, root2): \"\"\"检测两棵二叉树是不是镜像树 Args: root1 (TreeNode): 二叉树头结点 root2 (TreeNode): 二叉树头结点 Returns: bool: 是否为镜像树 \"\"\" if root1 is None and root2 is None: return True if root1 is None or root2 is None: return False if root1.val != root2.val: return False return self.is_symmetry_tree(root1.left, root2.right) and \\ self.is_symmetry_tree(root1.right, root2.left)def main(): root = TreeNode(8) root.left = TreeNode(6) root.right = TreeNode(6) root.left.left = TreeNode(5) root.left.right = TreeNode(7) root.right.left = TreeNode(7) root.right.right = TreeNode(5) ex = Solution() print(ex.is_symmetry_tree(root, root))if __name__ == '__main__': main() 题29：顺时针打印矩阵题目： 输入一个矩阵，按照从外向内以顺时针一次打印出每一个数字。 解法： 这个题主要是确定每次的打印范围，然后规范化打印之后再处理特殊情况： 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: \"\"\"matrix类型为二维列表，需要返回列表\"\"\" def printMatrix(self, matrix): res = [] row_length = len(matrix) col_length = len(matrix[0]) if row_length == 0 or col_length == 0: return res i = j = 0 m = row_length - 1 n = col_length - 1 while i &lt; m and j &lt; n: for _ in range(j, n): res.append(matrix[i][_]) for _ in range(i, m): res.append(matrix[_][n]) for _ in range(n, j, -1): res.append(matrix[m][_]) for _ in range(m, i, -1): res.append(matrix[_][j]) i += 1 j += 1 m -= 1 n -= 1 if i == m == j == n: res.append(matrix[i][j]) elif i == m: for _ in range(j, n+1): res.append(matrix[i][_]) elif j == n: for _ in range(i, m+1): res.append(matrix[_][n]) return res 举例让抽象问题具体化如果规律不能一眼看出来，那就试着用具体例子模拟过程吧。不要钻牛角尖，因为没有用。 题30：包含min函数的栈 使用辅助栈，辅助栈与主栈同步增长，辅助栈中放入已压入元素的最小值；辅助栈与主栈同步弹出； 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack = [] self.stack_min = [] self.min_value = None def push(self, node): if not self.stack: self.min_value = node else: self.min_value = min(self.min_value, node) self.stack.append(node) self.stack_min.append(self.min_value) def pop(self): self.stack_min.pop() return self.stack.pop() def top(self): return self.stack[-1] def min(self): return self.stack_min[-1] 题31：栈的压入、弹出序列解法： 如果要判断一个序列是不是栈的弹出序列，那么把压入序列真正的压入一遍就知道了。此题分析如下： 设立一个辅助栈和两个变量用作标志，一个指向弹出序列中的待弹出元素，一个指向压入序列中还未压入栈的元素，两个变量初始值都为0； 如果待弹出元素和栈顶元素不相同，那么就去待压入元素中寻找和待弹出元素相等的值，将其压入栈； 如果待弹出元素和栈顶元素相同，那么弹出栈顶，待弹出元素往后继续，重复这个过程直到变成条件2，再重复条件2； 在3中如果找不到相等元素，那么就说明弹出序列有问题。 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): if len(pushV) != len(popV): return False stack = [] cur_push = 0 cur_pop = 0 while stack or cur_push &lt; len(pushV): # cur_pop与栈顶相同，则弹出，cur_pop + 1 if stack and stack[-1] == popV[cur_pop]: stack.pop() cur_pop += 1 else: # cur_pop与栈顶不同，那么开始压栈，直到找到相等值 while cur_push &lt; len(pushV) and pushV[cur_push] != popV[cur_pop]: stack.append(pushV[cur_push]) cur_push += 1 if cur_push &lt; len(pushV): stack.append(pushV[cur_push]) cur_push += 1 # 去除长度不等之外的唯一错误情况：找不到相等值压栈 else: return False return True 题32：从上往下打印二叉树题目一：不分行打印题目二：分行打印 从上到下打印二叉树的每个节点，同一层的节点按照从左到右的顺序打印，代码实现的为分行打印。 解法：层次遍历，利用队列解，剩下的大家就都知道了。 123456789101112131415161718192021222324252627282930313233343536373839404142class TreeNode(): def __init__(self, val): self.val = val self.left = None self.right = Noneclass Solution(): def print_tree_with_level(self, root): if root is None: return None qu = [] qu.append(root) count = 0 while qu: to_be_print = len(qu) while to_be_print &gt; 0: temp = qu.pop(0) print(temp.val, end=' ') if temp.left: qu.append(temp.left) if temp.right: qu.append(temp.right) to_be_print -= 1 count += 1 print('第%d层\\n' % count)def main(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) ex = Solution() ex.print_tree_with_level(root)if __name__ == '__main__': main() 题目三：之字形打印二叉树题目： 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，如此反复。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding=utf-8 -*-class TreeNode(): def __init__(self, val): self.val = val self.left = None self.right = Noneclass Solution(): \"\"\"分层之字形打印二叉树 \"\"\" def Print(self, pRoot): if pRoot is None: return [] s1, s2, res = [], [], [] s1.append(pRoot) while s1 or s2: if s1: cur_level_res = [] while s1: item = s1.pop() cur_level_res.append(item.val) if item.left: s2.append(item.left) if item.right: s2.append(item.right) res.append(cur_level_res) if s2: cur_level_res = [] while s2: item = s2.pop() cur_level_res.append(item.val) if item.right: s1.append(item.right) if item.left: s1.append(item.left) res.append(cur_level_res) return resdef main(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) ex = Solution() print(ex.Print(root))if __name__ == \"__main__\": main() 题33：二叉搜索树的后序遍历序列题目： 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。假设数组中没有相同元素。 解法： 1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): length = len(sequence) if length &lt;= 0: return False root = sequence[-1] for i in range(length): if sequence[i] &gt; root: break j = i for j in range(i, length-1): if sequence[j] &lt; root: return False left = True if i &gt; 0: left = self.VerifySquenceOfBST(sequence[:i]) right = True if i &lt; length - 1: right = self.VerifySquenceOfBST(sequence[i:-1]) return left and right 题34：二叉树中和为某一值的路径题目： 输入一棵二叉树和一个整数，打印出二叉树中节点值得和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def FindPath(self, root, expectNumber): \"\"\"找到二叉树中和为某个值的路径 Args: root (TreeNode): 二叉树根节点 expectNumber (int): 目标和 Returns: list: 二维列表，内部每个列表表示找到的路径 \"\"\" if root is None: return [] res = [] def find_main(root, path, cur_sum): cur_sum += root.val path.append(root) is_leaf = True if root.left is None and root.right is None else False if cur_sum == expectNumber and is_leaf: one_path = [] for item in path: one_path.append(item.val) res.append(one_path) if cur_sum &lt; expectNumber: if root.left is not None: find_main(root.left, path, cur_sum) if root.right is not None: find_main(root.right, path, cur_sum) path.pop() find_main(root, [], 0) return res 分解让复杂问题简单化将大问题分解成小问题——怎样将大问题分解成小问题？无他，多练，就脑熟了。 题35：复杂链表的复制题目： 请实现函数复制一个复杂链表。在复杂链表中，每个节点除了有一个next指针指向下一个节点，还有一个sibling指针指向链表中的任意节点或者None。 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = Noneclass Solution: def Clone(self, pHead): \"\"\"返回克隆的复杂链表的头结点 Args: pHead (RandomListNode): 复杂链表头部 Returns: RanddomListNode: 复制链表头部 \"\"\" if pHead is None: return None buf_dict = {} copy_head = RandomListNode(pHead.label) p, copy_p = pHead, copy_head while p.next is not None: copy_p.next = RandomListNode(p.next.label) p = p.next copy_p = copy_p.next buf_dict[p] = copy_p p, copy_p = pHead, copy_head while p is not None: if p.random is not None: copy_p.random = buf_dict[p.random] p = p.next copy_p = copy_p.next return copy_head 题36：二叉搜索树与双向链表 输入一个二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新节点，只能调整树中节点指针的指向。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def Convert(self, pRootOfTree): \"\"\"将二叉搜索树与双向链表 Args: pRootOfTree (TreeNode): 二叉树根节点 Returns: TreeNode: 双向链表头部 \"\"\" if pRootOfTree is None: return pRootOfTree if pRootOfTree.left is None and pRootOfTree.right is None: return pRootOfTree def mid_order(root, res): if root is None: return res mid_order(root.right, res) res.append(root) mid_order(root.left, res) return res pre_res = mid_order(pRootOfTree, []) pre_res = pre_res[::-1] head = pre_res[0] head.left = None head.right = pre_res[1] if len(pre_res) &gt; 2: for i in range(1, len(pre_res)-1): temp = pre_res[i] temp.left = pre_res[i-1] temp.right = pre_res[i+1] pre_res[-1].right = None pre_res[-1].left = pre_res[-2] return head 题37：序列化二叉树题目： 请实现两个函数，分别用来序列化和反序列化二叉树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def Serialize(self, root): \"\"\"前序序列化二叉树 Args: root (TreeNo): 二叉树根节点 Returns: str: 序列化字符串 \"\"\" if root is None: return '#_' res = '%d_' % root.val res += self.Serialize(root.left) res += self.Serialize(root.right) return res def Deserialize(self, s): \"\"\"根据字符串反序列化由Serialize函数序列化的二叉树 Args: s (str): 序列化的字符串 Returns: TreeNode: 反序列化之后二叉树头结点 \"\"\" s = s.split('_')[:-1] def inside(s): head = s.pop(0) print(head) if head == '#': return None head = TreeNode(int(head)) head.left = inside(s) head.right = inside(s) return head return inside(s) 题38：字符串的排列解法： 全排列问题，可以用递归做。递归做的越多越发现有时候递归不是很好写。暂定以后的递归套路为分析最后情况，制定basecase必须要给递归返回有利条件。 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): if ss is None or len(ss) &lt; 2: return ss ss = list(ss) res = set({}) self.permut(ss, 0, res) return sorted(list(res)) def permut(self, ss, begin, res): if begin == len(ss) - 1: res.add(''.join(ss)) return cur = begin for cur in range(begin, len(ss)): self.swap(ss, begin, cur) # 交换 self.permut(ss, begin+1, res) self.swap(ss, begin, cur) # 复位 def swap(self, ss, i, j): ss[i], ss[j] = ss[j], ss[i]","link":"/2018/08/21/offer27-38/"},{"title":"","text":"To be continued. 原文链接 async/await在Python3.5中到底是怎么工作的？作为一个Python的核心开发者，我会想要去了解这种语言通常是怎么工作的。我意识到总会有那些我不知道所有细节的模糊角落出现，但是为了有助于解决问题以及Python的z总体设计，我感觉我应该尝试着理解它的核心语义以及这些东西在底层到底是如何工作的？ 但是直到最近，我还是不理解async/await在Python3.5中是怎么工作的。我知道在Python3.3中的yield from和Python3.4中的asyncio一起引出了这种新语法。但是由于网络相关的工作我做的不多–虽然asyncio不是局限于网络工作，但它的确是专注于此–这就让我没有对async/await投入太多关注。我的意思是我知道： 1yield from iterator 是（实际上）等效于： 12for x in iterator: yield x 我还知道asyncio是一个能够用来异步编程的事件循环框架，以及这些名词本身是什么意思。但是我从来没有深入到async/await语法中，去了解这些都是怎么结合到一起的。我觉得我并不了解Python中的异步编程，这让我有些苦恼。所以我决定慢慢来，去尝试弄明白这些东西到底是怎么工作的。并且我还从不同的人那里听到过他们也不太了解这个新的异步编程是怎么怎样的，所以我决定写这篇短文。（是的，这篇post用了太长时间，也写得太长了以至于我的妻子把它标记为essay）。 现在，因为我想正确理解这种语法是如何工作，所以本文有一些关于CPython是如何工作的底层技术细节。如果细节比你需要的多，或者由于我不想把这篇文章编程一本书而没有介绍CPython内部每一个细微差别导致你并不完全理解这些细节，这都是可以的。（举个例子，如果你不明白code对象有flags，更不用提连code对象都不知道，那你就不需要关心从这篇文章得到的相关code对象的东西。）我试着在每一个版块的尾部提供了一个很便于访问的总结，所以如果你发现你并不想了解那么多细节的话，你可以跳过它们，直接看总结。 协程在Python中的历史根据Wikipedia，协程是和子例程类似的面向非抢占式多任务的计算机程序组件，它允许多个进入点在一定位置暂停或继续执行。这是一种相当学术的说法，“协程是可以暂停执行的函数”。 如果你对自己解释说，“这听起来像生成器”，你就是对的。 在Python2.2中， 生成器（也被叫做生成迭代器，因为生成器实现了迭代器协议）是由PEP 255第一次引进的。主要受到Icon programming language的影响，生成器允许一种非常简单的，在计算下一个值时不浪费内存的创建迭代器的方法（你也可以实现一个实现了__iter__()和__next__()方法并且不保存迭代器每一个值的类，但这很费力气。）举个例子，如果你想创建你自己的range()函数，你可以通过创建一个整型列表来完成： 12345678def eager_range(up_to): \"\"\"创建一个整型列表，从0到up_to, 不包括up_to\"\"\" sequence = [] index = 0 while index &lt; up_to: sequence.append(index) index += 1 return sequence 这种实现的问题是，如果你需要一个很长的序列，比如从0到1000000，那么你需要创建一个足够长的能容纳100000个整数的列表。但是当生成器被引入Python之后，你就能够轻松的创建一个不需要提前生成整个序列的迭代器。实际上，你需要的只是一次有一个整型的内存就行了。 123456def lazy_range(up_to): \"\"\"返回0到up_to, 不包括上界的整型序列\"\"\" index = 0 while index &lt; up_to: yield index index += 1 不管函数在做什么，当它遇到一个yield表达式它就会暂停执行————虽然yield这个语句直到Python 2.5才出现————然后能够在接下来继续执行，这种特性对于减少内存使用以及生成无穷序列等等都是非常有用的。 但是你可能也已经发现了，生成器就是迭代器的样子。既然现在有一种更棒的构建迭代器的方法明显是更好地（这表现在当你在一个生成器对象上定义一个iter()方法的时候），但是人们知道如果我们把生成器中“暂停”的部分去掉，然后添加一种“把东西传入”的方法，Python就猛然有了协程的概念（除非我在其他地方说明了，要不然你把这些就当做Python里的概念；我们会稍后讨论Python中真正的协程）。然后生成器中能传递东西的方法是在Python 2.5引入的，感谢PEP 342。除此之外，PEP 342给生成器引入了send()方法。这不仅允许我们暂停生成器， 还允许我们把值传回到生成器暂停的地方。继续深入我们的range()例子，实现序列可以前跳或者后跳一定量： 123456789101112131415161718192021def jumping_range(up_to): \"\"\"Generator for the sequence of integers from 0 to up_to, exclusive. sending a value into the generator will shift the sequence by that amount. \"\"\" index = 0 while index &lt; up_to: jump = yield index if jump is None: jump = 1 index += jumpif __name__ == \"__main__\": iterator = jumping_range(5) print(next(iterator)) print(iterator.send(2)) print(next(iterator)) print(iterator.send(-1)) for x in iterator: print(x) 直到Python3.3，当PEP 380添加yield from 的时候生成器定义才再次被修改。严格的说，这个特性使得从迭代器(刚巧生成器也是迭代器）产出值变得更简单了，从而允许你以一种简单的方式重构生成器。 123456789def lazy_range(up_to): \"\"\"Generator to return the sequence of integers from 0 to up_to, exclusive.\"\"\" index = 0 def gratuitous_refactor(): nonlocal index while index &lt; up_to: yield index index += 1 yield from gratuitous_refactor() 除了重构更容易了之外，yield from还能够让你将生成器链到一起，这样无需代码做任何特殊的事情, 值就可以在调用栈中上下浮动。 1234567891011121314151617181920def bottom(): # Returning the yield lets the value that goes up the call stack to come right back # down. return (yield 42)def middle(): return (yield from bottom())def top(): return (yield from middle())# Get the generator.gen = top()value = next(gen)print(value) # Prints '42'.try: value = gen.send(value * 2)except StopIteration as exc: value = exc.valueprint(value) # Prints '84'. 总结：在Python 2.2中，生成器可以暂停执行的代码。然后在Python 2.5中引进了回传值到暂停的生成器中的功能之后，协程的概念在Python中出现就变得有可能了。再然后Python 3.3中新加入的yield from让重构生成器以及链接生成器都变得简单了。 事件循环是什么？如果你开始关注async/await，那么理解什么是时间循环以及它如何有利于异步编程就很重要了。如果你曾经做过GUI编程————包括网页前后端的工作————那么你就已经和时间循环打过交道了。但是鉴于在Python中异步编程是一种新的语言结构，所以如果你暂时不明白时间循环是什么也是可以的。 在Wikipedia的解释中， 时间循环“是一种编程结构，用来等待或者分发程序中的事件或者消息”。基本上，时间循环允许你执行，“当A发生时，执行B”，这种逻辑。解释这一点的最简单的例子可能是遍布于每个浏览器中JavaScript的时间循环。每当你单击某个内容（“当A发生时”），点击事件就被传递给JavaScript中的时间循环，它检查是否有onclick回调被注册用来处理这个点击事件（“do B”）。如果有任何回调被注册，那么附带着点击的细节，该回调就会被调用。事件循环之所以被认为是一个循环是因为它不断的收集事件并循环检测事件，以找到如何处理事件的方法。 在Python里，asyncio被添加到标准库中来提供事件循环。在使用asyncio进行网络编程的时候需要注意，在这种情况下，事件循环把“when A happens”当做是一个套接字的I/O已经准备好读或者写的时候（通过selectors模块）。除了GUI以及I/O，事件循环还通常作为调度器，用来执行另外一个线程或者子进程中的代码，比如cooperative multiasking。如果你恰好也了解Python的GIL，那么在释放GIL是可能和有用的情况下，事件循环是很有用的。 总结事件循环提供了一种循环使得你可以做到，“当A发生时，执行B”。实际上，事件循环就是监测一些事件的发生，然后当事件发生了之后，就调用关注该事件发生的代码。在Python3.4中，标准库asyncio用于提供事件循环。 async和await是怎样工作的？在Python3.4中工作的方式在Python3.3中有了生成器以后到有了asyncio形式的事件循环之间，Python3.4用并发编程的形式就足以支持异步编程。异步编程其实就是我们提前不知道执行顺序的编程（这也是异步而不是同步的原因）。并发编程是我们编写执行时与其他部分独立的代码，即使这些代码是在一个线程中执行的（并发不是并行）。例如，下面是在两个异步并发函数调用中每秒倒计时的Python3.4代码: 12345678910111213141516import asyncio# Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.@asyncio.coroutinedef countdown(number, n): while n &gt; 0: print('T-minus', n, '({})'.format(number)) yield from asyncio.sleep(1) n -= 1loop = asyncio.get_event_loop()tasks = [ asyncio.ensure_future(countdown(\"A\", 2)), asyncio.ensure_future(countdown(\"B\", 3))]loop.run_until_complete(asyncio.wait(tasks))loop.close() 在Python3.4中， asyncio.coroutine 装饰器用于将函数标记为协程，用于asyncio它的事件循环。这为Python提供了它对协程的第一个具体定义：一个对象，它实现了添加到PEP 342中的生成器的方法，并由collections.abc.coroutine抽象基类表示。这意味着，突然之间，所有的生成器都实现了协程接口，即使它们并不是被当做协程使用的。为了解决这个问题，asyncio要求将所有要用作协程的生成器都必须用asyncio.coroutine修饰。 有了这个协程的具体定义（与生成器提供的API相匹配），你就可以在任何[aysncio.Future对象][]上使用yield from，将这个对象传递到事件循环中，在等待事情发生的时候暂停其执行（future对象是asyncio的实现细节，并不重要）。一旦future对象到达了事件循环，它就会被监视, 直到future对象完成任何它需要完成的工作。一旦future完成了自己的工作，事件循环就会监测到，然后处于暂停状态的等待future结果的协程就会再次启动，它的结果也被send()方法传递到协程中。 接着分析上面的那个例子。事件循环启动每一个countdown()协程调用，一直执行到其中一个的yield from和asyncio.sleep()函数处。到这里会产生一个asyncio.Future对象，并被传递到事件循环中，然后暂停协程的执行。在事件循环中，事件循环监测这个future对象直到sleep的这一秒结束（同时也检查它正在监测的其他事物，比如其他的协程）。一旦这一秒结束了，事件循环找到那个提供future对象的处于暂停状态的协程，然后把future对象的结果发送到这个协程，然后协程继续运行。这个过程一直持续到所有的countdown()协程借宿运行，并且事件循环没有监测对象的时候。稍后，我会给你展示一个完整的协程或者事件循环这些东西工作的例子, 但是首先我想解释一下async和await是怎么工作的。 Python3.5: 从yield from到await在Python3.4中，出于异步编程的目的把一个函数标记为协程的过程想下面这样： 1234# 在Python3.5中同样生效@asyncio.coroutinedef py34_coro(): yield from stuff() 在Python3.5中，加入了types.coroutine装饰器和asyncio.coroutine一样用来标记一个生成器为协程。你还可以使用async def来语法上定义一个函数为协程，虽然它不能包含任何形式的yield表达式；只有return和await被允许从协程中返回一个值。 12async def py35_coro(): await stuff() async和types.coroutine做的一个关键的事情就是缩减了协程的定义。它把协程从一个只是接口变成了一种确切的类型，把其他生成器和用来做协程的生成器之间的区别更严格了（inspect.iscoroutine()函数更严格了，它固定协程必须使用async）。 你可能还注意到了除了async，在Python3.5的例子中还引入了await表达式（只能在async def定义的函数中使用）。虽然await运行起来跟yield from很像，但是await表达式接收的对象确是不同的。协程可以在await表达式中使用，因为协程就是所有这些东西的基础。但是当你在一个对象上调用await时，这个对象技术上需要是一个awaitable对象：一个定义了__await__()方法并且返回一个迭代器，而不是返回协程本身的对象。协程被认为是awaitable对象（这也是为什么collections.abc.Coroutine继承自collections.abc.Awaitable）。这个定义遵循了Python底层上把大部分的语法定义都转换到一个方法调用上的传统，就像a+b在底层实际上是a.__add__(b)或者b.__radd__(a)。 那么在底层上yield from和awati有什么区别呢（也就是一个使用types.coroutine装饰器定义的生成器和一个用async def定义的生成器的区别）？让我们看一下上面的两个例子在Python3.5中的字节码，来了解一下本质区别。`py34_coro()的字节码是： 123456789&gt;&gt;&gt; dis.dis(py34_coro) 2 0 LOAD_GLOBAL 0 (stuff) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 GET_YIELD_FROM_ITER 7 LOAD_CONST 0 (None) 10 YIELD_FROM 11 POP_TOP 12 LOAD_CONST 0 (None) 15 RETURN_VALUE py35_coro()的字节码是： 123456789&gt;&gt;&gt; dis.dis(py35_coro) 1 0 LOAD_GLOBAL 0 (stuff) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 GET_AWAITABLE 7 LOAD_CONST 0 (None) 10 YIELD_FROM 11 POP_TOP 12 LOAD_CONST 0 (None) 15 RETURN_VALUE 忽略那行由于py34_coro()拥有asyncio.coroutine装饰器造成的区别，两者唯一肉眼可见的区别就是GET_YIELD_FROM_ITER字节码和GET_AWAITABLE字节码的不同。两个函数都被正确的标记成协程，所以并没有什么区别。在使用GET_YIELD_FROM_ITER的情况下，它只是简单的检查一下它的参数是不是一个生成器或者协程，如果不是，它就会对它的参数调用iter()方法（只有当yield from的字节码在协程里使用的时候，该字节码才能接受一个协程对象，在这个例子中是正确的需要感谢types.coroutine装饰器标记了这个生成器就像在C语言层面上用CO_ITERABLE_COROUTINE 标记代码对象一样）。 但是，GET_AWAITABLE字节码做了一些不同的事情。虽然这个字节码接收一个跟GET_YIELD_FROM_ITER接收的一样的协程，但是它不会接收一个没有被标记为协程的生成器。除了协程，这个字节码还像我们前面讨论的那样接收一个awaitable对象。这就使得yield from表达式和await表达式都接收协程对象，同时不同的地方在于它们是否分别接收一个普通的生成器或者awaitable对象。 你可能想知道为什么基于async的协程和基于生成器的协程在各自的暂停表达式中会接收不同的参数？这样做的原因是Python尽最大的努力确保你不会搞砸了，并且意外的混合和匹配那些恰好拥有相同API的对象。鉴于生成器继承性的实现了协程的API，那么当你希望使用一个协程的时候，就很可能意外的使用了生成器。而且由于并不是所有的生成器都被用编写用在一个基于协程的控制流程中，你需要避免不正确的使用生成器。但是由于Python不是静态编译的，Python能给你的最大保障就是当你使用一个基于生成器的协程的时候执行运行时检查。这意味着当使用types.coroutine的时候，Python的编译器分辨不出这个生成器是要被用作协程或者只是用着生成器（记住，语法上写types.coroutine'并不意味着有人已经提前做了types = spam`的检查），因此，不同的操作码有不同的限制是由编译器根据它当时的情景给出的。 关于基于生成器的协同程序和基于async的协程之间的区别，我想说的一个非常关键的一点是，只有基于生成器的协程才能真正暂停执行并且强制传递一些东西到时间循环。你通常不会注意到这一重要的细节，因为你通常会调用事件循环特定的函数，比如asyncio.sleep()由于事件循环实现了它们自己的API，这些函数都必须考虑这个小细节。对于大多数的我们，我们会使用事件循环而不是编写它们，因此我们只编写aync协程而不需要真正的关心这个问题。但是如果你和我一样，并且正在好奇为什么你不能编写一些像asyncio.sleep()这种只使用async协程的函数，那么这将是一个非常好的时刻。 总结让我们简单总结一下上面的东西。使用async def定义一个方法使得这个函数成为协程。另一个制作协程的方式是用types.coroutine标记一个生成器——实际上这个标记其实是对代码对象做CO_ITERABLE_COROUTINE标记——或者是一个collections.abc.Coroutine的子类。你只能使用一个基于生成器的协程的时候才能暂停一个协程调用链。 一个awaitable对象要么是一个协程，要么是一个定义了__await__()的对象——实际上是collections.abc.Awaitable——它返回一个迭代器而不是协程。一个await表达式基本上就是yield from，但是有只能和awaitable对象一起使用（纯粹的生成器不能再await表达式中使用）。一个async函数是一个协程，它要么含有return语句——包括Python中每一个函数末尾都有的隐式return None语句——要么还包括或者只有await表达式（yield表达式是不允许使用的）。这个对于async`函数的限制是为了确保你不会意外的将基于生成器的协程和其他生成器混用，毕竟这两种类型的生成器的期望使用方式是相当不同的。 把async/await当做异步编程的一个API我想指出的一个关键事情是直到我看了David Beazley’s Python Brasil 2015年的幻灯片之前都没有深入思考过的事情。在那个讲座里，David指出了async/await实际上是异步编程的一个API（这也是他在twitter上对我重申的）。David说这个的意思是人们不应该把async/await当成和asyncio一样的东西，而是把asyncio想象成一个替异步编程实现async/awaitAPI的框架。 David相信async/await是一个异步编程的API以至于他创建了curio项目去实现他自己的事件循环。这让我更清楚的认识到，async/await允许Python为异步编程提供基础，但是并不将你绑定到特定的事件循环或者其他的底层细节当中（这与直接将事件循环集成到语言中的其他编程语言不通）。这使得curio这样的项目，不仅能够在较低的级别上以不同的方式运行（例如，aasyncio使用future对象来作为和事件循环交流的API，而curio使用元组），而且还可以具有不同的关注点和性能特种（例如，asyncio有一个完整的框架来实现传输和协议层，这使得它具有扩展性，而curio更简单，并且希望用户自己关心这类问题，但是也让它运行的更快了）。 基于Python中（短））的异步编程历史，人们可能认为async/await == asyncio就是可以理解的。我是说asyncio是使得在Python3.4中异步编程变得可能以及在Python3.5中添加async/await的动力因素。但是async/await的设计目的是要足够灵活到不再需要asyncio或者针对该框架扭曲任何关键决策。换句话说，async/await延续了Python的传统，即设计东西时尽可能灵活，同时又能实用的使用（和实现）。 一个例子到了现在你脑子里可能充斥着各种名词和概念，使得明白所有这些东西时如何使用来给你提供异步编程变得有些困难。为了使得这些都更确切，这是一个完整的（如果设计的）异步编程例子，从事件循环和相关函数到用户代码的端到端示例。这个例子有代表独立火箭发射倒计时的协程，但是看起来确是同步倒计时的。这就是通过并发的异步编程；三个独立的协程会独立运行，而且这一切都在一个线程中完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# -*- coding: utf-8 -*-\"\"\"一个完整的异步编程的例子\"\"\"import datetimeimport heapqimport typesimport timeclass Task: \"\"\"代表一个协程在重新运行之前应该等待多久 实现的比较运算符是给heapq用的。不幸的是，由于当datetime.datetime实例相等的时候，比较就会传到协程，而协程没有实现比较方法，两个元素的元组就不能用。 把这个当成asyncio.Task/curio.Task. \"\"\" def __init__(self, wait_until, coro): self.coro = coro self.waiting_until = wait_until def __eq__(self, other): return self.waiting_until == other.waiting_until def __lt__(self, other): return self.waiting_until &lt; other.waiting_untilclass SleepingLoop: \"\"\"着重于延迟协程执行的事件循环 把这个想象成`asyncio.BaseEventLoop/curio.Kernel`。 \"\"\" def __init__(self, *coros): self._new = coros self._waiting = [] def run_unitl_complete(self): # 启动所有协程 for coro in self._new: wait_for = coro.send(None) heapq.heappush(self._waiting, Task(wait_for, coro)) # 一直运行到没有任务 while self._waiting: now = datetime.datetime.now() # 获取具有最近恢复时间的协程 task = heapq.heappop(self._waiting) if now &lt; task.waiting_until: # 我们比计算超前，等待直到下次运行时间 delta = task.waiting_until - now time.sleep(delta.total_seconds()) now = datetime.datetime.now() try: # 唤醒协程 wait_until = task.coro.send(now) heapq.heappush(self._waiting, Task(wait_until, task.coro)) except StopIteration: # 协程结束 pass@types.coroutinedef sleep(seconds): \"\"\"暂停一个协程指定的秒数 把这个当成`asyncio.sleep()/curio.sleep()` \"\"\" now = datetime.datetime.now() wait_until = now + datetime.timedelta(seconds=seconds) # 将所有调用栈的协程暂停；`yield`的使用使得这个函数成为一个基于生成器的而不是基于`async`的协程 actual = yield wait_until # 唤醒执行函数栈，返回我们实际上等待了多久 return actual - nowasync def countdown(label, length, *, delay=0): \"\"\" length秒的发射倒计时，等待delay秒数 这是一个用户的普通写法。 \"\"\" print(label, 'waiting', delay, 'seconds before starting countdown') delta = await sleep(delay) print(label, 'starting after waiting', delta) while length: print(label, 'T-minus', length) waited = await sleep(1) length -= 1 print(label, 'lift-off!')def main(): \"\"\"启动事件循环，倒数三个独立的发射 这就是一个用户会编写的经典代码。 \"\"\" loop = SleepingLoop(countdown('A', 5), countdown( 'B', 3, delay=2), countdown('C', 4, delay=1)) start = datetime.datetime.now() loop.run_unitl_complete() print('Total elapsed time is', datetime.datetime.now() - start)if __name__ == '__main__': main() To be continued.","link":"/2018/08/23/how-the-heck-does-async-and-await-work-in-python3.5/"},{"title":"剑指offer 第五章 题39-52题解 Python版","text":"Github 时间效率类考察题：节省时间就是延长生命。：） 题39：数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为9的数组{1， 2， 3，2， 2， 2， 5， 4， 2} 解法： 1.借用partition函数： 如果一个元素在数组中出现次数超过一半，那么该元素一定也占据排序数组中位数位置。我们可以利用快排partition过程求得数组中位数元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-import randomclass Solution: def MoreThanHalfNum_Solution(self, numbers): if len(numbers) &lt;= 0: return None length = len(numbers) l, r = 0, length - 1 middle = length &gt;&gt; 1 m_left, m_right = self.partition(numbers, l, r) while middle not in range(m_left, m_right+1): if middle &lt; m_left: r = m_left - 1 m_left, m_right = self.partition(numbers, l, r) else: l = m_right + 1 m_left, m_right = self.partition(numbers, l, r) return numbers[middle] if numbers.count(numbers[middle]) &gt; length // 2 else 0 def partition(self, numbers, l, r): \"\"\"快排partition过程 Arguments: numbers {list} -- 数组 l {int} -- 左边界 r {int} -- 右边界 Returns: tuple -- 第一个元素为本轮选中元素占据的最左索引，第二个元素为本轮选中元素占据的最右索引 如果本轮选中元素在数组中只有一个，那么tuple中两个元素就是相等的。 \"\"\" self.swap(numbers, random.randint(l, r), r) start = l - 1 end = r while l &lt; end: if numbers[l] &lt; numbers[r]: start += 1 if start != l: self.swap(numbers, start, l) l += 1 elif numbers[l] == numbers[r]: l += 1 else: end -= 1 self.swap(numbers, l, end) self.swap(numbers, end, r) return start + 1, end def swap(self, numbers, i, j): numbers[i], numbers[j] = numbers[j], numbers[i] 2.使用题目中元素特性 如果数组中一个元素出现的次数大于数组长度的一半，那么该元素出现的次数大于数组中其他元素出现的次数和。所以可以设计一个count变量用来统计元素个数，具体过程如下：1.count初始值设为0， 遍历数组2.当前遍历到的数组元素假定为cur，那么如果此时count值为0，count值就加一，继续遍历，如果遍历到的元素等于cur，count值就加一，反之就减一；3.返回最后一个将count设为1的元素；同样的，我们需要检测最后输出元素是否出现次数是大于数组长度的一半的。 123456789101112131415161718192021# -*- coding:utf-8 -*-import randomclass Solution: def MoreThanHalfNum_Solution(self, numbers): if len(numbers) &lt;= 0: return None count = 0 for i in range(len(numbers)): if count == 0: flag = numbers[i] count += 1 else: if numbers[i] != flag: count -= 1 else: count += 1 return flag if numbers.count(flag) &gt; len(numbers) // 2 else 0 题39衍生题：给定整数K，求长度为N的数组中元素出现次数超过N/K的元素解法： 这个题跟题39一脉相承，在题39中，我们的解法原型其实是每次都数组里删除两个不同的元素，如果数组中存在出现次数超过数组一般的元素，那么不同元素对删除完成之后剩下的元素一定是所求元素。现在拓展开来，如果我们要求数组中出现次数大于N/K的元素，那么我们一次删除k-1个，最后剩余的k-1个也就包含出现次数大于N/K的元素。拓展情况是包括题39的，拓展情况代码流程如下：&emsp;&emsp;1.首先设定一个大小为k-1的字典（出现次数超过N/K的元素，最多只可能有k-1个）;&emsp;&emsp;2.遍历数组，检测当前元素是否在字典里，&emsp;&emsp;&emsp;&emsp;1.如果在字典里，字典里对应key的value值加一; &emsp;&emsp;&emsp;&emsp;2.如果不在字典里:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;字典未满时，以当前遍历到的数组元素为key，value设为1;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如果字典已满，那么将字典中所有key对应的value值都减去1（即从数组中删除了K个不同的元素）;&emsp;&emsp;3.每遍历一个元素，删除字典中value值小于1的元素。最后在字典里的元素就包括所求元素，我们做最后的检查就行了。上面两种情况所求的的数据，我们都要最终校验数据是不是真的出现了符合要求的次数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding=utf-8 -*-def get_nk_item(arr, k): \"\"\"求数组中出现次数超过N/K的元素 Arguments: arr {list} -- 数组 k {int} -- 分母 Returns: tuple -- 所求元素 \"\"\" if len(arr) &lt; k: return 0 buf_dict = {} for i in range(len(arr)): if arr[i] in buf_dict: buf_dict[arr[i]] += 1 else: if len(buf_dict) &lt; k - 1: buf_dict[arr[i]] = 1 else: for item in buf_dict: buf_dict[item] -= 1 remove_invalid(buf_dict) check_valid(arr, k, buf_dict) return tuple(buf_dict.keys())def remove_invalid(buf_dict): \"\"\"删除buf_dict中value值小于1的元素\"\"\" buf_remove = [] for item in buf_dict: if buf_dict[item] &lt; 1: buf_remove.append(item) for item in buf_remove: buf_dict.pop(item)def check_valid(arr, k, buf_dict): \"\"\"检测所求的元素是否满足次数要求\"\"\" buf_remove = [] for item in buf_dict: if arr.count(item) &lt;= len(arr) // k: buf_remove.append(item) for item in buf_remove: buf_dict.pop(item) 题40：最小的k个数 输入n个整数，找出其中个最小的k个数。例如，输入4、5、1、6、2、7、3、8这八个数，则最小的4个数字是1、2、3、4. 解法： 1.借用partition函数 如题39，我们可以借用partition函数在O(n)的时间复杂度内找到排序数组中索引为k的元素，然后输出前k个元素就行了，注意：此时输出的前k个元素是无序的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding:utf-8 -*-import randomclass Solution: def GetLeastNumbers_Solution(self, tinput, k): if tinput is None or k is None or k &gt; len(tinput) or k &lt;= 0: return [] if k == len(tinput): return tinput l, r = 0, len(tinput) - 1 m_left, m_right = self.partition(tinput, l, r) while k not in range(m_left, m_right+1): if k &lt; m_left: r = m_left - 1 m_left, m_right = self.partition(tinput, l, r) else: l = m_right + 1 m_left, m_right = self.partition(tinput, l, r) return tinput[:k] def partition(self, arr, l, r): self.swap(arr, random.randint(l, r), r) start = l - 1 end = r while l &lt; end: if arr[l] &lt; arr[r]: start += 1 if l != start: self.swap(arr, l, start) l += 1 elif arr[l] == arr[r]: l += 1 else: end -= 1 self.swap(arr, l, end) self.swap(arr, end, r) return start+1, end def swap(self, arr, i, j): arr[i], arr[j] = arr[j], arr[i] 2.借用堆的概念 使用partition函数我们会破坏原有数组，如果不破坏原有数组就得复制一个新数组，如果数组很长，那么无疑partition的解法就有了缺点；使用堆我们就能很好的处理大数据的问题：1.首先我们利用数组前k个元素建立一个大小为k的最大堆；2.然后从数组第k+1个元素开始, &emsp;&emsp;如果当前元素小于堆顶，那么将堆顶弹出，然后将当前元素加入堆，并再次调节好堆, 继续遍历过程；&emsp;&emsp;如果当前元素大于堆顶，那么继续遍历； 在方法二的代码实现中，我利用了python自带模块heapq. 12345678910111213141516171819# -*- coding:utf-8 -*-import heapqclass Solution: def GetLeastNumbers_Solution(self, tinput, k): if tinput is None or k is None or k &gt; len(tinput) or k &lt;= 0: return [] res = [] for i in range(k): res.append(-tinput[i]) heapq.heapify(res) for i in range(k, len(tinput)): if tinput[i] &lt; -res[0]: res[0] = -tinput[i] heapq.heapify(res) return sorted(list(map(lambda x: -x, res))) 题41：数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数组排序之后位于中间的值。如果从数据流中读出偶数个个数值，那么中位数就是所有数组排序之后中间两个数的平均值。 解法： 要求中位数随时可以求得，那么构建一个最大堆，一个最小堆，并且保持最大堆与最小堆中元素个数差值不超过2. 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-import heapqclass Solution: def __init__(self): self.min_heap = list([]) self.max_heap = list([]) def Insert(self, num): if not self.min_heap and not self.max_heap: heapq.heappush(self.min_heap, num) return if num &gt; self.min_heap[0]: heapq.heappush(self.min_heap, num) else: heapq.heappush(self.max_heap, -num) if abs(len(self.min_heap) - len(self.max_heap)) &gt; 1: self.balance() def balance(self): pop_heap, push_heap = (self.min_heap, self.max_heap) if len( self.min_heap) &gt; len(self.max_heap) else (self.max_heap, self.min_heap) while len(pop_heap) - len(push_heap) &gt; 1: heapq.heappush(push_heap, -heapq.heappop(pop_heap)) def GetMedian(self): if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2 else: return -self.max_heap[0] if len(self.max_heap) &gt; len(self.min_heap) else self.min_heap[0] 题42：连续子数组的最大和 输入一个整型数组，数组里有正数也有负数。数组中一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n). 解法： 1.普通方法，遍历数组求解最大和： 在遍历数组过程中，我们设定一个变量cur_sum用来统计当前和，设定一个变量max_sum用来保存当前已经遍历过的元素组成的数组里的最大子数组和。 在每一步遍历中，我们都比较cur_sum和我们记录的max_sum, 将较大的那个值设定为新的max_sum：如果cur_sum当前值为正，那么cur_sum加上当前遍历元素可能比cur_sum要更大，此时cur_sum 就加上当前遍历元素；如果cur_sum当前值为负，那么cur_sum机上当前遍历元素一定要比当前遍历到的元素小，那么明显的这个cur_sum不可能是最大的子数组和，此时将cur_sum设置为当前遍历到的元素，开启一个新的子数组和的计算。 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): if array is None: return None if len(array) &lt; 2: return sum(array) max_sum = min(array) cur_sum = 0 for item in array: if cur_sum &lt; 0: cur_sum = item else: cur_sum += item if cur_sum &gt; max_sum: max_sum = cur_sum return max_sum 2.使用动态规划： 状态方程： 233333，这题用动态规划好简单。。12f(n) = f(n-1) + arr[n] if f(n-1) &gt; 0 &lt;br&gt;f(n) = arr[n] if f(n-1) &lt;= 0 123456789101112131415class Solution: def FindGreatestSumOfSubArray(self, arr): if arr is None: return None if len(arr) &lt; 2: return sum(arr) res = [arr[0] for x in range(len(arr))] for i in range(1, len(arr)): if res[i-1] &lt;= 0: res[i] = arr[i] else: res[i] = res[i-1] + arr[i] return max(res) 题43：1~n整数中1出现的次数 输入一个整数n，求1~n这n个数整数的十进制表示中1出现的次数。例如，输入12，1~12这些证书中包含1的数字有1、10、11和12，1一共出现了5次。 解法： 1234567891011121314151617181920212223242526272829303132# -*- coding=utf-8 -*-class GetOccurTimesOfOne(): \"\"\"计算1-n中所有数字中1出现的次数\"\"\" def get_occur_time_of_one(self, num): if num is None or num &lt; 1: return 0 length = self.get_num_length(num) first = int(str(num)[0]) # 第一位 if first == 1: first_sum = num % self.base_10(length-1) + 1 if first != 1: first_sum = self.base_10(length - 1) # 其他位 other_num = self.base_10(length - 2) * (length - 1) * first next_num = self.get_occur_time_of_one(num % self.base_10(length-1)) return first_sum + other_num + next_num def base_10(self, length): num = 1 while length &gt; 0: num *= 10 length -= 1 return num def get_num_length(self, num): length = 0 while num != 0: length += 1 num = num // 10 return length 题44： 数字序列中某一位的数字 数字以 0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1， 第19位是4，等等。倾斜一个函数，求任意第n位对应的数字。 解法： 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding=utf-8 -*-import sysdef get_nth_num_of_sequence(n): if n is None or n &lt; 0: return None if n &lt; 10: return n # 判断第n位的数组是几位数组以及对应位数数组在序列中开始的位置 full_length, start = get_length_and_delta(n) # n位为几位数的第几个数的第几位 nth, delta = (n - start) // full_length, (n - start) % full_length num = base_10(full_length - 1) + nth return int(str(num)[delta])def get_nth_of_num(num, i): num = list(str(num)) return int(num[i])def base_10(length): num = 1 while length &gt; 0: num *= 10 length -= 1 return numdef get_length_and_delta(n): start = i = 1 while start &lt;= n: more = 9 * (10 ** (i - 1)) * i start += more i += 1 return i - 1, start - moreif __name__ == \"__main__\": n = int(sys.argv[1]) print(get_nth_num_of_sequence(n)) 题45：把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如，输入数组{3， 32， 321}， 则打印出这三个数字能排成的最小数字321323. 解法： 剑指offer上的解法定义自定义比较器很贪心，自己用了另外一种解法，更清楚明了。 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): if numbers is None or len(numbers) &lt; 1: return None temp_dict = {key: str(value) for key, value in enumerate(numbers)} longest = self.get_longest(temp_dict.values()) for i in range(len(temp_dict)): while len(temp_dict[i]) &lt; longest: temp_dict[i] = temp_dict[i] + temp_dict[i][-1] res = [] for item in sorted(temp_dict.items(), key=lambda item: item[1]): res.append(numbers[item[0]]) return int(''.join(map(str, res))) def get_longest(self, arr): longest = 0 for item in arr: if len(item) &gt; longest: longest = len(item) return longestif __name__ == \"__main__\": nums = [3, 32, 321] ex = Solution() print(ex.PrintMinNumber(nums)) 题46：把数字翻译成字符串 给定一个数字，我们按照如下规则把它翻译成字符串：0翻译成’a’, 1翻译成‘b’， ……， 11翻译成‘I’， ……， 25翻译成‘z’。一个数字可能有多个翻译。例如，12258有5种不同的翻译，分别是’bccfi’、‘bwfi’、‘bczi’、‘mcfi’和’mzi’。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 解法： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding=utf-8 -*-class Solution(): # 暴力递归版本 def convert_int_to_str_recur(self, num): if num &lt; 0: return None num = str(num) return self.process(num, 0) def process(self, num, index): if index &gt;= len(num) - 1: return 1 p1 = self.process(num, index+1) p2 = self.process(num, index+2) if int(num[index:index+2]) &lt;= 25 else 0 return p1 + p2 # 动态规划版本 def convert_int_to_str(self, num): if num &lt; 0: return None num = str(num) res = [0 for i in range(len(num))] res [-1], res[-2] = 1, 2 if int(num[-2:]) &lt;= 25 else 1 for i in range(len(num)-3, -1, -1): res[i] = res[i+1] if int(num[i:i+2]) &lt;= 25: res[i] += res[i+2] return res[0]if __name__ == \"__main__\": num = 12226 ex = Solution() print(ex.convert_int_to_str(num)) 题47：礼物的最大价值 在一个mxn的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘左下角开始拿格子里的礼物，并且每次向右或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘以及上面的礼物，请计算能达到的最大价值数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding=utf-8 -*-class Solution(): def max_value_of_presents_recur(self, arr): if arr is None: return None if len(arr) == 0 or len(arr[0]) == 0: return 0 row_l = len(arr) col_l = len(arr[0]) return self.process(arr, 0, 0, row_l-1, col_l-1) def process(self, arr, i, j, row_l, col_l): if i == row_l and j == col_l: return arr[i][j] if i == row_l: res = arr[i][j] + self.process(arr, i, j+1, row_l, col_l) elif j == col_l: res = arr[i][j] + self.process(arr, i+1, j, row_l, col_l) else: res = arr[i][j] + max(self.process(arr, i, j+1, row_l, col_l), self.process(arr, i+1, j, row_l, col_l)) return res # 动态规划版本 def max_value_of_presents(self, arr): if arr is None: return None if len(arr) == 0 or len(arr[0]) == 0: return 0 row_l = len(arr) col_l = len(arr[0]) res = [[0 for i in range(len(arr[0]))] for i in range(len(arr))] res[row_l-1][col_l-1] = arr[row_l-1][col_l-1] i = row_l - 1 for j in range(col_l-2, -1, -1): res[i][j] = arr[i][j] + res[i][j+1] j = col_l - 1 for i in range(row_l-2, -1, -1): res[i][j] = arr[i][j] + res[i+1][j] for i in range(row_l-2, -1, -1): for j in range(col_l-2, -1, -1): res[i][j] = arr[i][j] + max(res[i+1][j], res[i][j+1]) return res[0][0]if __name__ == \"__main__\": arr = [[1, 10, 3, 8], [12, 2, 9, 6], [5, 7, 4, 11], [3, 7, 16, 5], ] ex = Solution() print(ex.max_value_of_presents(arr)) 题48：最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长字符串的长度。假设字符串中只包含‘a’-‘z’的字符。例如，在字符串“arabcacfr”中，最长的不含重复字符的字符串是“acfr”，长度为4. 解法： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding=utf-8 -*-class Solution(): def get_max_length_of_undup_str(self, string): if string is None or len(string) &lt;= 1: return int(string) if string is not None else None res = [0 for i in range(len(string))] index_arr = [-1 for i in range(52)] res[0] = 1 index_arr[self.get_index(0, string)] = 0 for i in range(1, len(string)): char_index = self.get_index(i, string) delta = i - index_arr[char_index] if index_arr[char_index] == -1 or delta &gt; res[i-1]: res[i] = res[i-1] + 1 else: res[i] = delta # 更新当前字符的最新索引 index_arr[char_index] = i return res[-1] def get_index(self, index, string): temp = ord(string[index]) if 65 &lt;= temp &lt;= 90: return temp - ord('A') elif 97 &lt;= temp &lt;= 122: return temp - ord('a') + 26 else: raise TypeError('not a valid char!')if __name__ == \"__main__\": string = 'arabcacfr' # answer is 4 ex = Solution() print(ex.get_max_length_of_undup_str(string)) 时间效率与空间效率的平衡鱼与熊掌兼得 题49： 丑数 我们把只包含因子2、3和5的数称为丑数（Ugly Number）。求从小到大的书序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7.习惯上我们把1当做第一个丑数。 解法： 12345678910111213141516171819202122232425262728293031323334# -*- coding=utf-8 -*-import numbersclass Solution: def GetUglyNumber_Solution(self, index): assert isinstance(index, numbers.Integral) if index &lt; 1: return None ugly = [1] while len(ugly) &lt;= index: for item in ugly: if item * 2 &gt; ugly[-1]: break p1 = item * 2 for item in ugly: if item * 3 &gt; ugly[-1]: break p2 = item * 3 for item in ugly: if item * 5 &gt; ugly[-1]: break p3 = item * 5 ugly.append(min(p1, p2, p3)) return ugly[-1]if __name__ == \"__main__\": n = [2, 3, 4, 5, 6, 7] ex = Solution() for item in n: print(ex.GetUglyNumber_Solution(item)) 题50：第一个只出现一次的字符 在字符串中找出第一个只出现一次的字符。如输入“abaccdeff”, 则输出‘b’ 解法： 耍流氓式解法：利用Python标准库Counter计数器。Counter计算器会根据字符在字符串中出现的先后顺序返回字符在字符串中出现的次数，我们只要找到Counter中第一个value值为1的key就好了。 12345678910111213141516# -*- coding:utf-8 -*-from collections import Counterclass Solution: def FirstNotRepeatingChar(self, s): if s is None: return -1 if len(s) == 0: return -1 counter = Counter(s) for i in range(len(s)): if counter[s[i]] == 1: return i return -1 题51： 数组中的逆序对解法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding=utf-8 -*-class Solution(): def InversePairs_recur(self, data): if data is None or len(data) &lt; 2: return 0 return self.merge(data, 0, len(data)-1) def merge(self, data, left, right): if left == right: return 0 middle = left + ((right - left) &gt;&gt; 1) left_pairs = self.merge(data, left, middle) right_pairs = self.merge(data, middle+1, right) merge_pairs = self.process(data, left, right, middle) return left_pairs + right_pairs + merge_pairs def process(self, data, left, right, middle): l, r = left, middle+1 pairs = 0 cur = left temp_arr = [0 for i in range(len(data))] while l &lt;= middle and r &lt;= right: # 如果左边数组元素l大于右边数组元素r，则有逆序对middle - l + 1 if data[l] &gt; data[r]: temp_arr[cur] = data[r] r += 1 cur += 1 pairs += middle - l + 1 else: temp_arr[cur] = data[l] l += 1 cur += 1 while l &lt;= middle: temp_arr[cur] = data[l] cur += 1 l += 1 while r &lt;= right: temp_arr[cur] = data[r] r += 1 cur += 1 for i in range(left, right+1): data[i] = temp_arr[i] return pairs 牛客网提示这个算法超时，我开始以为写的有问题，还改成了非递归归并，后来仔细想了想，不管是递归归并还是非递归归并时间复杂度都是O(nlogn)，所以应该是牛客的问题，后来果然发现，随便直接输出一个值也会提示超时。。。呵呵哒。。 题52：两个链表的第一个公共节点 输入两个链表，找出他们的第一个公共节点。链表节点定义如下：12345struct ListNode{ int m_nkey; ListNode* m_pNext;} 解法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def FindFirstCommonNode(self, pHead1, pHead2): if pHead1 is None or pHead2 is None: return None loop1 = self.check_loop(pHead1) loop2 = self.check_loop(pHead2) # 都有环 if loop1 and loop2: p = loop1 while p.next != loop1: if p == loop2: return loop1 p = p.next return None # 都无环 elif (not loop1) and (not loop2): p1, p2 = pHead1, pHead2 while p1 != p2: p1 = pHead1 if p1 is None else p1.next p2 = pHead2 if p2 is None else p2.next return p1 else: return None @staticmethod def check_loop(pHead): if pHead.next is None: return False buf_dict = {} p = pHead while p is not None: if p in buf_dict: return p buf_dict[pHead] = 0 p = p.next return False","link":"/2018/08/25/offer39-52/"},{"title":"剑指offer 第六章 题53-66题解 Python版","text":"Github 知识迁移能力举一反三：能力是培养的，加油吧。 题53：在排序数组中查找数字题目一：数字在排序数组中出现的次数 统计一个数字在排序数组中出现的次数。例如，输入排序数组{1，2，3，3，3，3，4，5}和数字3，由于3在这个数组中出现了4次，因此输出4. 题目二：0~n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0~n-1之内。在范围0~n-1之内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 题目三：数组中数值和下标相等的元素 假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在数组{-3， -1， 1， 3， 5}中，数字3和它的下标相等。 解法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): \"\"\"计算排序数组中数字出现的次数 Arguments: data {list} -- 数组 k {int} -- 待寻找数字 Returns: int -- 找到返回个数，找不到返回0 \"\"\" if k is None or len(data) &lt; 1: return 0 if k &lt; data[0] or k &gt; data[-1]: return 0 first = self.get_occur_location(data, k, True) last = self.get_occur_location(data, k, False) if first == last and first == -1: return 0 else: return last - first + 1 def get_occur_location(self, data, k, first): right = len(data) - 1 left = 0 while left &lt;= right: middle = left + ((right - left) &gt;&gt; 1) if data[middle] == k: if first: if middle - 1 &gt; -1 and data[middle-1] == k: right = middle - 1 else: return middle else: if middle + 1 &lt; len(data) and data[middle+1] == k: left = middle + 1 else: return middle elif data[middle] &gt; k: right = middle - 1 else: left = middle + 1 return -1 def get_missing_number(self, arr): \"\"\"找到长度为n-1的递增排序数组中不在0~n-1范围内的数字 Arguments: arr {list} -- 长度为n-1的递增排序数组 \"\"\" if arr is None or len(arr) &lt; 1: return None return self.binary_find_missing_number(arr) def binary_find_missing_number(self, arr): left, right = 0, len(arr) - 1 while left &lt;= right: middle = left + ((right - left) &gt;&gt; 1) if arr[middle] == middle: left = middle + 1 elif middle == 0 or (middle - 1 &gt;= 0 and arr[middle-1] == middle-1): return middle else: right = middle - 1 return -1 def find_index_equls_value_item(self, arr): \"\"\"找到单调递增且不重复数组中数值和下标相等的元素 Arguments: arr {list} -- 数组 Returns: int -- 找到返回下标，找不到返回1 \"\"\" if arr is None or len(arr) &lt; 1: return None return self.binary_find_equls_item(arr) def binary_find_equls_item(self, arr): left, right = 0, len(arr) - 1 while left &lt;= right: middle = left + ((right - left) &gt;&gt; 1) if arr[middle] == middle: return middle elif arr[middle] &lt; middle: left = middle + 1 else: right = middle - 1 return -1if __name__ == \"__main__\": nums = [1, 2, 3, 3, 3, 3] nums2 = [0, 1, 2, 3, 5] nums3 = [1, 2, 3, 4] nums4 = [-3, -1, 1, 3, 5] ex = Solution() print(ex.GetNumberOfK(nums, 3)) print(ex.get_missing_number(nums2)) print(ex.get_missing_number(nums3)) print(ex.find_index_equls_value_item(nums4)) 题54：二叉搜索树的第K大节点题目： 给定一颗二叉搜索树，请找出第k大的节点。 解法： 利用二叉搜索树的中序遍历为递增数组的特性，即可得结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): if pRoot is None or k &lt; 1: return None cur = pRoot res = -1 while cur: most_right = cur.left if most_right: while most_right.right and most_right.right != cur: most_right = most_right.right # 第一次遍历到cur节点 if most_right.right is None: most_right.right = cur cur = cur.left continue # 第二次遍历到cur节点 if most_right.right == cur: most_right.right = None k -= 1 if k == 0: # 为了不破坏原二叉树结构，没有直接返回cur节点 res = cur cur = cur.right return None if res == -1 else resif __name__ == \"__main__\": root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(6) root.right.right = TreeNode(8) ex = Solution() print(ex.KthNode(root, 4)) # The answer is TreeNode(5) 题55： 二叉树的深度题目一： 求二叉树的深度 输入一课二叉树的根节点，求该树的深度。 123456789class Solution: def TreeDepth(self, pRoot): if pRoot is None: return 0 depthl = self.TreeDepth(pRoot.left) depthr = self.TreeDepth(pRoot.right) return max(depthl, depthr) + 1 题目二： 平衡二叉树 输入一课二叉树的根节点，判断该树是不是平衡二叉树。 解法： 这个题在我前面关于树形dp的帖子里。 题56：数组中数字出现的次数题目一：数组中只出现一次的两个数字 一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n),空间复杂度是O(1). 解法： 空间复杂度O(1)意味着我们不能借用辅助数组。解法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): if array is None or len(array) &lt; 2: return [] res = self.get_xor(array) flag = self.get_index(res) help_arr1, help_arr2 = [], [] for item in array: res = self.get_bit(item, flag) if res: help_arr1.append(item) else: help_arr2.append(item) return [self.get_xor(help_arr1), self.get_xor(help_arr2)] def get_xor(self, arr): res = 0 for item in arr: res = res ^ item return res def get_index(self, res): \"\"\"得到异或结果其中一位为1的位置 Arguments: res {int} -- 原数组异或结果 \"\"\" period = 0 while period &lt; 32: if res &amp; 1 == 1: return period res = res &gt;&gt; 1 period += 1 def get_bit(self, num, index): # 将给定index位置的bit移到最低位 while index &gt; 0: num = num &gt;&gt; 1 index -= 1 return num &amp; 1if __name__ == \"__main__\": ex = Solution() nums = [2, 4, 3, 6, 3, 2, 5, 5] print(ex.FindNumsAppearOnce(nums)) # The answer is [6, 4]. 题目二：数组中唯一只出现一次的数字。 在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现了一次的数字。 解法： 123456789101112131415161718192021222324252627282930# -*- coding=utf-8 -*-class Solution(): def find_item(self, arr): if arr is None or len(arr) &lt; 4 or len(arr) % 3 != 1: return None temp = [0 for i in range(32)] for item in arr: bit_mark = 1 for i in range(31, -1, -1): # 使用bit_mark每次左移结果去与可以防止溢出 bit = item &amp; bit_mark if bit != 0: temp[i] += 1 bit_mark = bit_mark &lt;&lt; 1 res = 0 # 注意生成数时候的顺序 for _ in temp: res = res &lt;&lt; 1 res += _ % 3 return resif __name__ == \"__main__\": ex = Solution() arr = [3, 3, 3, 1] print(ex.find_item(arr)) 题57：和为s的数字题目一：和为s的两个数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 解法： 因为数组是递增的，那就好办了，首尾相加求和，然后往里推进。 12345678910111213141516171819202122# -*- coding=utf-8 -*-def two_sum(arr, g_sum): if arr is None or len(arr) &lt; 2: return None start, end = 0, len(arr) -1 while start &lt; end: if arr[start] + arr[end] == g_sum: return arr[start], arr[end] elif arr[start] + arr[end] &lt; g_sum: start += 1 else: end -= 1 return Noneif __name__ == \"__main__\": arr = [1, 2, 4, 7, 11, 15] g_sum = 15 print(two_sum(arr, g_sum)) 题目二：和为s的连续正数序列 输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如，输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以打印出3个连续序列1~5，4~6和7~8. 解法： 类比题目一，构建初始区间，然后检测条件，根据条件更改区间。 123456789101112131415161718192021def get_sequence(g_sum): if g_sum &lt; 3: return None small, big = 1, 2 res = [] while small &lt;= g_sum // 2: cur_sum = sum(range(small, big+1)) if cur_sum == g_sum: res.append((small, big)) big += 1 elif cur_sum &lt; g_sum: big += 1 else: small += 1 return resif __name__ == \"__main__\": print(get_sequence(15)) 题58：翻转字符串题目一：翻转单词顺序 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序保持不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串“I am a student.”,则输出“student. a am I”. 解法： 这个题用Python写也跟作弊似的。但是有正经解法的，正经解法是先把字符串整个翻转，然后再以空格为区分，翻转字符串里的每一个单词。 1234567891011# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): if s is None or len(s) &lt; 1: return s # 排除只含有空格的字符串 if s.strip() == '': return s s = s.split() return ' '.join(s[::-1]) 题目二：左旋转字符串 字符串的左旋转操作是字符串前面的若干个字符转移到字符串尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefgt” 和数字2，该函数将返回左旋转两位得到的结果“cdefgab”” 解法： 这个用Python切片可以作弊式完成。但建议非Python语言使用者还是用正经解法把：1.首先用给定数字把字符分成两部分，第一部分为待左移字符串，第二部分为原剩余字符串;2.再分别翻转这两个部分；3.将这两个部分合并起来，然后再翻转合并后的字符串。 123456789# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): if s is None or len(s) &lt; 1: return s n = n % len(s) pre, post = s[:n], s[n:] return post + pre 题59：队列的最大值题目一：滑动窗口的最大值 给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2，3，4，2，6，2，5，1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4，4，6，6，6，5}. 解法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-from collections import dequeclass Solution: def maxInWindows(self, num, size): if num is None or size is None: return [] if size &lt; 1 or size &gt; len(num): return [] res = [] helper = deque() for i in range(size): self.expand(num, i, helper) res.append(num[helper[0]]) l = 0 for i in range(size, len(num)): self.expand(num, i, helper) l += 1 self.shrink(num, l, helper) res.append(num[helper[0]]) return res def expand(self, num, index, helper): if not helper: helper.append(index) elif num[index] &lt; helper[-1]: helper.append(index) else: while helper and num[index] &gt;= num[helper[-1]]: helper.pop() helper.append(index) def shrink(self, num, l, helper): while helper and helper[0] &lt; l: helper.popleft()if __name__ == \"__main__\": ex = Solution() num = [2, 3, 4, 2, 6, 2, 5, 1] print(ex.maxInWindows(num, 3)) 题目二：队列的最大值 请定义一个队列并实现max得到队列里的最大值，要求函数max，push_back 和pop_front的时间复杂度都是O(1)。 解法： 借用上题的思想，给队列建立一个影子队列用来存放最大值，当队列添加一个元素的时候，影子队列执行expand操作，当队列pop_front的时候，影子队列执行一次shrink操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding=utf-8 -*-from collections import dequeclass WithMaxQueue(): \"\"\"能O(1)时间复杂度返回队列最大值的队列实现： 实现了pop_front以及push_back方法 \"\"\" def __init__(self): \"\"\"初始化，self.__l, self.__r两个参数很重要 params: self.__queue: 存储数据的队列 self.__shadow: 存储数据队列中最大值的队列 self.__l: 等价于滑动窗口左边界，表示当前队列头部是第几个添加进来的元素 self.__r: 等价于滑动窗口右边界，表示当前队列尾部是第几个添加进来的元素 \"\"\" self.__queue = deque() self.__shadow = deque() self.__l, self.__r = 0, 0 def push_back(self, item): self.__queue.append(item) self.expand(item) self.__r += 1 def pop_front(self): if self.__queue: self.__queue.popleft() self.__l += 1 self.shrink() else: raise IndexError(\"pop from emtpy queue\") def expand(self, item): \"\"\"滑动窗口的扩大过程：即当有新元素时，对最大值队列的调整 \"\"\" if not self.__shadow: self.__shadow.append((self.__r, item)) else: if item &lt; self.__shadow[-1][-1]: self.__shadow.append((self.__r, item)) else: while self.__shadow and item &gt;= self.__shadow[-1][-1]: self.__shadow.pop() self.__shadow.append((self.__r, item)) def shrink(self): \"\"\"滑动窗口的缩小过程（窗口左边界右移）即：当弹出元素时，对最大值队列的调整 \"\"\" while self.__shadow and self.__l &gt; self.__shadow[0][0]: self.__shadow.popleft() def get_max(self): return self.__shadow[0][-1]if __name__ == \"__main__\": ex = WithMaxQueue() num = [2, 3, 4, 2, 6, 2, 5, 1] # The anster is 4, 4, 6, 6, 6, 5 for i in range(3): ex.push_back(num[i]) print(ex.get_max()) for i in range(3, len(num)): ex.push_back(num[i]) ex.pop_front() print(ex.get_max()) 抽象建模能力建模两步走： 选择合理的数据结构来表述问题； 分析模型中的内在规律，并用编程语言表述这种规律。 题60：n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能值出现的概率。 解法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# -*- coding=utf-8 -*-import numbersimport timeclass Solution(): \"\"\"求n个骰子扔在地上，所有骰子正面向上点数和s的各种情况及其出现概率 \"\"\" def __init__(self, dice=6): self.dice_numbers = dice def get_sum_recur(self, n): \"\"\"递归求解版本 Arguments: n {int} -- 骰子个数 Returns: list -- 包含元素为（s, probability）, s为和，probability为s出现概率。 \"\"\" assert isinstance(n, numbers.Integral) if n &lt; 1: return [(0, 1)] res_arr = [0 for i in range((self.dice_numbers - 1) * n + 1)] self.recur_process(n, res_arr) total = self.dice_numbers ** n res_arr = [(i + n, res_arr[i] / total) for i in range(len(res_arr))] return res_arr def recur_process(self, n, res_arr): for i in range(1, self.dice_numbers + 1): self.process(n, n, i, res_arr) def process(self, n, remain, cur_sum, res_arr): if remain == 1: res_arr[cur_sum - n] += 1 else: for i in range(1, self.dice_numbers+1): self.process(n, remain-1, cur_sum+i, res_arr) def get_sum(self, n): \"\"\"非递归求解版本 \"\"\" assert isinstance(n, numbers.Integral) if n &lt; 1: return [(0, 1)] p1 = [0] * 2 p1[0] = [0 for i in range(self.dice_numbers*n+2)] p1[1] = [0 for i in range(self.dice_numbers*n+2)] # flag用来每次循环时，复用上轮循环的结果 flag = 0 for i in range(1, self.dice_numbers+1): p1[flag][i] = 1 for i in range(2, n+1): for j in range(i): # 和不可能小于i p1[1-flag][j] = 0 for j in range(i, self.dice_numbers*i+1): p1[1-flag][j] = 0 k = 1 while k &lt;= self.dice_numbers and k &lt; j: p1[1-flag][j] += p1[flag][j-k] k += 1 flag = 1 - flag total = self.dice_numbers ** n res = [] for i in range(n, self.dice_numbers*n+1): res.append((i, p1[flag][i]/total)) return resif __name__ == \"__main__\": n = 10 print('{}个骰子的情况下：'.format(n)) ex = Solution() start = time.time() print(\"递归求解结果：\\n{}\".format(ex.get_sum_recur(n))) first_period = time.time() - start print(\"非递归求解结果：\\n{}\".format(ex.get_sum(n))) second_period = time.time() - start - first_period print(\"递归用时：{}, 非递归用时：{} \\n递归用时是非递归用时的 {} 倍。\".format( first_period, second_period, first_period/second_period)) 当n=10的时候，就已经能看见巨大差距了： 12递归用时：24.436681985855103, 非递归用时：0.0007491111755371094递归用时是非递归用时的 32620.90165499682 倍。 题61：扑克牌中的顺子 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这五张牌是不是连续的。2~10为数字本身，A为1， J为11， Q为12，K为13，而大小王可以看成任意数字。 解法：这类题就是看看代码能力了。有两点需要注意：1.数组中不能出现除了0之外的重复数字;2.连续的非零数字之间的正常间距为1 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): if numbers is None or len(numbers) != 5: return [] numbers.sort() length = len(numbers) times = numbers.count(0) for i in range(length-1): if numbers[i] == 0: continue delta = numbers[i+1] - numbers[i] if delta == 0: return False elif delta - 1 &lt;= times: times -= delta - 1 else: return False return Trueif __name__ == \"__main__\": nums = [1, 3, 2, 6, 4] ex = Solution() print(ex.IsContinuous(nums)) 题62：圆圈中最后剩下的数字 0,1,…, n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里出去第m个数字，求这个圆圈里剩下的最后一个数字。 解法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution_1(self, n, m): \"\"\"利用辅助数组解法 Arguments: n {int} -- 人数 m {int} -- 删除第m个元素 Returns: int -- 最后剩余人代号 \"\"\" if n &lt; 1 or m &lt; 0: return -1 arr = [i for i in range(n)] cur = 0 while len(arr) != 1: period = m - 1 while period: cur = self.next_index(arr, cur) period -= 1 arr.pop(cur) if cur &gt;= len(arr): cur = 0 return arr[-1] def next_index(self, arr, cur): return 0 if cur &gt;= len(arr) - 1 else cur + 1 def LastRemaining_Solution_2(self, n, m): \"\"\"f(n, m) = (f(n - 1, m) + m) % n 如果不做映射，f(n-1, m)结果相当于f(n, m)淘汰第一个人之后的下一步，但调整了剩余的n-1 人的代号之后，我们需要确定的映射关系，能把调整之后的代号转换到初始包含n个人的情况下的代号 这样返回的结果也是和最初数据对应的。 \"\"\" if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n+1): last = (last + m) % i return lastif __name__ == \"__main__\": ex = Solution() n, m = 5, 3 print(ex.LastRemaining_Solution_2(n, m)) 题63：股票的最大利润 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？例如，一只股票在某些时间节点的价格为{9， 11， 8，5，7， 12， 16， 14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大利润11. 1234567891011121314151617181920# -*- coding=utf-8 -*-def get_max_profit(arr): if arr is None or len(arr) &lt; 2: return 0 min_price = arr[0] max_profit = arr[1] - min_price for item in arr[2:]: if item &lt; min_price: min_price = item max_profit = max(max_profit, item - min_price) return max_profitif __name__ == \"__main__\": num = [9, 11, 8, 5, 7, 12, 16, 14] print(get_max_profit(num)) # The anster is 11 发散思维能力：积累越多，发散能力自然越强，加油！ 题64：求1+2+…+n 求1+2+…+n，要求不能用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C） 解法： 短路求值：对于Python来说: a and b if a return b else return a 123456789# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): if n &lt; 1: return 0 ans = n emp = n and self.Sum_Solution(n-1) ans += temp return ans 题65：不用加减乘除做加法 写一个函数，求两个整数之和，要求函数体内不得使用“+”、“_”、“*”、“/”四则运算符号 解法：Python中的位操作和其他语言是有些许不同的。。 123456789# -*- coding:utf-8 -*-class Solution: def Add(self, a, b): while(b &amp; 0xFFFFFFFF &gt; 0): # 防止b溢出32位范围 a, b = (a ^ b), ((a &amp; b) &lt;&lt; 1) # 判断a是否溢出 if abs(a) &gt;= 0xFFFFFFFF: return a &amp; 0xFFFFFFFF return a 题66：构建乘积数组 给定一个数组A[0,1, … n-1], 请构建一个数组B[0,1,…,n-1],其中B中的元素B[i] = A[0]xA[1]x…xA[i-1]xA[i+1]x..xA[n-1]。不能使用除法。 解法： 这个题如果自己解，就只有用笨办法了，但剑指offer提供的这种解法未免太6了，分成两部分，同时代码实现也很巧妙，Python版如下，请飨。 123456789101112131415161718192021222324252627# -*- coding=utf-8 -*-def get_multi_list(arr): if arr is None or len(arr) &lt; 1: return -1 if len(arr) == 1: return arr length = len(arr) res = [0 for i in range(len(arr))] res[0] = 1 for i in range(1, length): res[i] = res[i-1]*arr[i-1] temp = 1 for j in range(length-2, -1, -1): temp *= arr[j+1] res[j] *= temp return resif __name__ == \"__main__\": num = [1, 2, 3, 4, 5] print(get_multi_list(num))","link":"/2018/08/25/offer53-66/"},{"title":"LeetCode每日一题题解集","text":"GitHub repo题解集GitHub Repo 顺便推荐一个终端刷LeetCode的工具：leetcode-cli，如果不想每次刷LeetCode开浏览器或者和我一样是终端vim党，可以试用一下。个人使用觉得优点： 支持关键字搜索，配合插件可以实现分公司查询题目； 支持指定语言的模板文件生成； 借助插件，可以实现submit通过之后自动push到对应Github仓库。 LeetCode 71: Simplify Path如果程序有一些情况需要回退，那么优先就考虑一下能不能使用栈。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253## [71] Simplify Path## https://leetcode.com/problems/simplify-path/description/## algorithms# Medium (26.95%)# Total Accepted: 124.7K# Total Submissions: 461.5K# Testcase Example: '\"/home/\"'## Given an absolute path for a file (Unix-style), simplify it. ## For example,# path = \"/home/\", =&gt; \"/home\"# path = \"/a/./b/../../c/\", =&gt; \"/c\"# path = \"/a/../../b/../c//.//\", =&gt; \"/c\"# path = \"/a//b////c/d//././/..\", =&gt; \"/a/b/c\"## In a UNIX-style file system, a period ('.') refers to the current directory,# so it can be ignored in a simplified path. Additionally, a double period# (\"..\") moves up a directory, so it cancels out whatever the last directory# was. For more information, look here:# https://en.wikipedia.org/wiki/Path_(computing)#Unix_style## Corner Cases:### Did you consider the case where path = \"/../\"?# In this case, you should return \"/\".# Another corner case is the path might contain multiple slashes '/' together,# such as \"/home//foo/\".# In this case, you should ignore redundant slashes and return \"/home/foo\".#class Solution: def simplifyPath(self, path): \"\"\" :type path: str :rtype: str \"\"\" path = path.split('/') stack = [] jump = ('', '.', '..') for item in path: if stack and item == '..': stack.pop() elif item not in jump: stack.append(item) return '/' + '/'.join(stack) LeetCode 53: maximum subarray*典型动规** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546## [53] Maximum Subarray## https://leetcode.com/problems/maximum-subarray/description/## algorithms# Easy (41.14%)# Total Accepted: 367K# Total Submissions: 890.6K# Testcase Example: '[-2,1,-3,4,-1,2,1,-5,4]'## Given an integer array nums, find the contiguous subarray (containing at# least one number) which has the largest sum and return its sum.## Example:### Input: [-2,1,-3,4,-1,2,1,-5,4],# Output: 6# Explanation: [4,-1,2,1] has the largest sum = 6.### Follow up:## If you have figured out the O(n) solution, try coding another solution using# the divide and conquer approach, which is more subtle.##class Solution: def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len(nums) if length &lt; 2: return sum(nums) max_res = pre_res = nums[0] for i in range(1, length): pre_res = nums[i] if pre_res &lt;= 0 else nums[i] + pre_res max_res = max(max_res, pre_res) return max_res LeetCode 28: Implement strStr()KMP算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485## [28] Implement strStr()## https://leetcode.com/problems/implement-strstr/description/## algorithms# Easy (29.86%)# Total Accepted: 316K# Total Submissions: 1.1M# Testcase Example: '\"hello\"\\n\"ll\"'## Implement strStr().## Return the index of the first occurrence of needle in haystack, or -1 if# needle is not part of haystack.## Example 1:### Input: haystack = \"hello\", needle = \"ll\"# Output: 2### Example 2:### Input: haystack = \"aaaaa\", needle = \"bba\"# Output: -1### Clarification:## What should we return when needle is an empty string? This is a great# question to ask during an interview.## For the purpose of this problem, we will return 0 when needle is an empty# string. This is consistent to C's strstr() and Java's indexOf().##class Solution: def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" if not needle: return 0 h_length, n_length = len(haystack), len(needle) if h_length &lt; n_length: return -1 next_arr = self.get_next_arr(needle) i = j = 0 while i &lt; h_length and j &lt; n_length: if haystack[i] == needle[j]: i += 1 j += 1 elif next_arr[j] == -1: i += 1 else: j = next_arr[j] return i - j if j == n_length else -1 def get_next_arr(self, needle): length = len(needle) if length &lt; 2: return [-1] next_arr = [0 for i in range(length)] next_arr[0], next_arr[1] = -1, 0 i, cur = 2, 0 while i &lt; length: if needle[cur] == needle[i-1]: next_arr[i] = cur + 1 cur = next_arr[i] i += 1 elif cur &gt; 0: cur = next_arr[cur] else: next_arr[i] = 0 i += 1 return next_arr 刚刚随手写kmp的时候发现，上面代码get_next_arr函数while循环里最后一个else分支里少些了i += 1，这样竟然也通过了leetcode的提交。醉了。顺便还试验了下，本来在strStr函数里，我是可以直接把needle的长度传给get_next_arr函数的，但后来发现，这样的话运行时间反而会加长。。只能说函数多传一个参数比在函数里多建一个变量用时更长啊。 LeetCode 7: Reverse Integer1234567891011121314151617181920212223242526272829303132333435363738394041424344## [7] Reverse Integer## https://leetcode.com/problems/reverse-integer/description/## algorithms# Easy (24.43%)# Total Accepted: 480.9K# Total Submissions: 2M# Testcase Example: '123'## Given a 32-bit signed integer, reverse digits of an integer.## Example 1:# Input: 123# Output: 321## Example 2:# Input: -123# Output: -321## Example 3:# Input: 120# Output: 21## Note:# Assume we are dealing with an environment which could only store integers# within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of# this problem, assume that your function returns 0 when the reversed integer# overflows.class Solution: def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" ans = str(x)[::-1] if x &gt;= 0 else '-' + str(x)[:0:-1] ans = int(ans) if ans &lt; - 2 ** 31 or ans &gt; 2 ** 31 - 1: ans = 0 return ans LeetCode 15: 3Sum有些时候，如果列表内元素需要重复访问的话，可以将其赋给变量，这个题把nums[left], nums[middle], nums[right]赋给变量比直接使用多打败了20%的提交的人。：） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071## [15] 3Sum## https://leetcode.com/problems/3sum/description/## algorithms# Medium (22.03%)# Total Accepted: 383.4K# Total Submissions: 1.7M# Testcase Example: '[-1,0,1,2,-1,-4]'## Given an array nums of n integers, are there elements a, b, c in nums such# that a + b + c = 0? Find all unique triplets in the array which gives the sum# of zero.## Note:## The solution set must not contain duplicate triplets.## Example:### Given array nums = [-1, 0, 1, 2, -1, -4],## A solution set is:# [# ⁠ [-1, 0, 1],# ⁠ [-1, -1, 2]# ]###class Solution: def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" length, res = len(nums), [] if length &lt; 3: return res nums.sort() for left in range(length-2): a = nums[left] if a &gt; 0: break if left &gt; 0 and a == nums[left-1]: continue middle = left + 1 right = length - 1 while middle &lt; right: b, c = nums[middle], nums[right] cur_sum = a + b + c if cur_sum == 0: res.append([a, b, c]) middle += 1 right -= 1 while middle &lt; right and nums[middle] == nums[middle-1]: middle += 1 while right &gt; middle and nums[right] == nums[right+1]: right -= 1 elif cur_sum &lt; 0: middle += 1 else: right -= 1 return res LeetCode 21: Merge Two Sorted Lists能用if else区分情况就不要用两个if，会慢。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869## [21] Merge Two Sorted Lists## https://leetcode.com/problems/merge-two-sorted-lists/description/## algorithms# Easy (42.96%)# Total Accepted: 409.2K# Total Submissions: 948.5K# Testcase Example: '[1,2,4]\\n[1,3,4]'## Merge two sorted linked lists and return it as a new list. The new list# should be made by splicing together the nodes of the first two lists.## Example:## Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4# Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4#### Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" if l1 is None: return l2 elif l2 is None: return l1 if l1.val &lt;= l2.val: head = l1 l1 = l1.next else: head = l2 l2 = l2.next cur = head while l1 and l2: if l1.val &lt;= l2.val: cur.next = l1 l1 = l1.next cur = cur.next else: cur.next = l2 l2 = l2.next cur = cur.next while l1: cur.next = l1 l1 = l1.next cur = cur.next while l2: cur.next = l2 l2 = l2.next cur = cur.next return head LeetCode 20: Valid Parentheses12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182## [20] Valid Parentheses## https://leetcode.com/problems/valid-parentheses/description/## algorithms# Easy (34.54%)# Total Accepted: 402.5K# Total Submissions: 1.2M# Testcase Example: '\"()\"'## Given a string containing just the characters '(', ')', '{', '}', '[' and# ']', determine if the input string is valid.## An input string is valid if:### Open brackets must be closed by the same type of brackets.# Open brackets must be closed in the correct order.### Note that an empty string is also considered valid.## Example 1:### Input: \"()\"# Output: true### Example 2:### Input: \"()[]{}\"# Output: true### Example 3:### Input: \"(]\"# Output: false### Example 4:### Input: \"([)]\"# Output: false### Example 5:### Input: \"{[]}\"# Output: true###class Solution: def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" if not s: return True elif len(s) % 2 == 1: return False else: check_dict = {'(':')', '{':'}', '[':']'} stack = [] for item in s: if item in check_dict: stack.append(item) else: if not stack or check_dict[stack[-1]] != item: return False else: stack.pop() return True if not stack else False LeetCode 300: Longest Increasing Subsequence1. 第一种最普遍解法，每次往前遍历所有已知lis数组元素，来更新lis[i]，时间复杂度`O(N2)`。** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354## [300] Longest Increasing Subsequence## https://leetcode.com/problems/longest-increasing-subsequence/description/## algorithms# Medium (39.22%)# Total Accepted: 154.8K# Total Submissions: 394.3K# Testcase Example: '[10,9,2,5,3,7,101,18]'## Given an unsorted array of integers, find the length of longest increasing# subsequence.## Example:### Input: [10,9,2,5,3,7,101,18]# Output: 4# Explanation: The longest increasing subsequence is [2,3,7,101], therefore the# length is 4.## Note:### There may be more than one LIS combination, it is only necessary for you to# return the length.# Your algorithm should run in O(n2) complexity.### Follow up: Could you improve it to O(n log n) time complexity?##class Solution: def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len(nums) if length &lt; 2: return length res = [1 for i in range(length)] i = 1 while i &lt; length: temp = nums[i] res[i] = 1 for j in range(i-1, -1, -1): if temp &gt; nums[j]: res[i] = max(res[i], res[j]+1) i += 1 return max(res) 2. 一种新思路的解法， 跟解法一比较除了使用lis数组来保存以对应位置元素结尾的最长递增序列的长度之外，额外添加了一个max_v数组，对应数组元素max_v[i]代表i长度的递增子序列里的最大值的最小值；有了这个数组之后，我们就可以从当前已知最长的递增子序列长度cur_max开始递减匹配（递减匹配过程中，用j作中间变量），那么如果当前元素nums[i]大于max_v[j]，那么i位置最长的递增子序列长度lis[i]=j+1，同时我们要根据lis[i]的值来决定更不更新cur_max；同时也要根据num[i]是否小于max_v[j+1]来确定更不更新最长递增子序列长度为j+1的那些递增子序列的最大值，此算法时间复杂度`O(n2)`。** 12345678910111213141516171819202122232425262728293031323334class Solution: def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len(nums) if length &lt; 2: return length max_v = [0 for i in range(length+1)] max_v[0] = min(nums) - 1 max_v[1] = nums[0] lis = [1 for i in range(length)] cur_max = 1 for i in range(1, length): for j in range(cur_max, -1, -1): if nums[i] &gt; max_v[j]: lis[i] = j + 1 break # 如果更新了当前最大值，那么更新max_v if lis[i] &gt; cur_max: cur_max = lis[i] max_v[cur_max] = nums[i] # 如果没有更新最大值，那么找到可能被i更新的j # 当nums[i] &gt; max_v[j]也就是进入到了上面for循环中的if条件中 # 如果进入了条件中，那么如果nums[i]比原来max_v[j+1]小的时候才有 # 更新价值； elif nums[i] &gt; max_v[j] and nums[i] &lt; max_v[j+1]: max_v[j+1] = nums[i] return cur_max **3. 上面的顺序匹配过程还可以改成二分，因为如果i&gt;j, 那么一定有max_v[i] &gt; max_v[j]，此算法时间复杂度O(n*logn)。** 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len(nums) if length &lt; 2: return length max_v = [0 for i in range(length+1)] max_v[0] = min(nums) - 1 max_v[1] = nums[0] lis = [1 for i in range(length)] cur_max = 1 for i in range(1, length): index = self.get_index(max_v[:cur_max+1], nums[i]) if index &gt;= 0: max_v[index+1] = nums[i] cur_max = max(cur_max, index+1) return cur_max def get_index(self, max_v, num): length = len(max_v) if num &gt; max_v[-1]: return length - 1 if num &lt; max_v[0]: return -1 low = 0 high = length - 1 while low &lt;= high: middle = low + ((high - low) &gt;&gt; 1) if max_v[middle] &lt; num and max_v[middle+1] &gt; num: return middle elif max_v[middle] == num: return -1 elif max_v[middle] &gt; num: high = middle - 1 else: low = middle + 1 LeetCode 5: Longest Palindromic Substring 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465## [5] Longest Palindromic Substring## https://leetcode.com/problems/longest-palindromic-substring/description/## algorithms# Medium (25.62%)# Total Accepted: 370.8K# Total Submissions: 1.4M# Testcase Example: '\"babad\"'## Given a string s, find the longest palindromic substring in s. You may assume# that the maximum length of s is 1000.## Example 1:### Input: \"babad\"# Output: \"bab\"# Note: \"aba\" is also a valid answer.### Example 2:### Input: \"cbbd\"# Output: \"bb\"###class Solution: def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" if s is None: return '' length = len(s) if length &lt; 2: return s s = self.str_trans(s) length = len(s) res = [1 for i in range(length)] i = 0 while i &lt; length: j, step = i, 1 while j-step &gt; -1 and j+step &lt; length and s[j-step] == s[j+step]: res[i] += 2 step += 1 i += 1 lp = max(res) lp_index = res.index(lp) lp = lp // 2 lp = s[lp_index-lp:lp_index+lp+1] return lp.replace('#', '') def str_trans(self, s): s = list(s) for i in range(len(s)): s[i] = '#' + s[i] s.append('#') return ''.join(s) 使用manacher算法的解法： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" if s is None: return '' length = len(s) if length &lt; 2: return s s = self.str_trans(s) length = len(s) res = [1 for i in range(length)] right = c = -1 for i in range(length): res[i] = min(res[2*c-i], right-i) if right &gt; i else 1 while i-res[i] &gt; -1 and i+res[i] &lt; length: if s[i-res[i]] == s[i+res[i]]: res[i] += 1 else: break res[i] -= 1 if i + res[i] &gt; right: right = i + res[i] c = i lp = max(res) lp_index = res.index(lp) lp = s[lp_index-lp:lp_index+lp+1] return lp.replace('#', '') def str_trans(self, s): s = list(s) for i in range(len(s)): s[i] = '#' + s[i] s.append('#') return ''.join(s) LeetCode 9: Palindrome Number [boring question]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657## [9] Palindrome Number## https://leetcode.com/problems/palindrome-number/description/## algorithms# Easy (38.18%)# Total Accepted: 399.3K# Total Submissions: 1M# Testcase Example: '121'## Determine whether an integer is a palindrome. An integer is a palindrome when# it reads the same backward as forward.## Example 1:### Input: 121# Output: true### Example 2:### Input: -121# Output: false# Explanation: From left to right, it reads -121. From right to left, it# becomes 121-. Therefore it is not a palindrome.### Example 3:### Input: 10# Output: false# Explanation: Reads 01 from right to left. Therefore it is not a palindrome.### Follow up:## Coud you solve it without converting the integer to a string?##class Solution: def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" x = list(str(x)) low, high = 0, len(x)-1 while low &lt; high: if x[low] != x[high]: return False low += 1 high -= 1 return True LeetCode 6: ZigZag这个题还是挺有意思的，主要是分析以及实现。剑指offer上说的没错，借助几个具体例子，很容易就能摸清一般规律，解法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788## [6] ZigZag Conversion## https://leetcode.com/problems/zigzag-conversion/description/## algorithms# Medium (28.47%)# Total Accepted: 239.9K# Total Submissions: 838K# Testcase Example: '\"PAYPALISHIRING\"\\n3'## The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number# of rows like this: (you may want to display this pattern in a fixed font for# better legibility)### P A H N# A P L S I I G# Y I R### And then read line by line: \"PAHNAPLSIIGYIR\"## Write the code that will take a string and make this conversion given a# number of rows:### string convert(string s, int numRows);## Example 1:### Input: s = \"PAYPALISHIRING\", numRows = 3# Output: \"PAHNAPLSIIGYIR\"### Example 2:### Input: s = \"PAYPALISHIRING\", numRows = 4# Output: \"PINALSIGYAHRPI\"# Explanation:## P I N# A L S I G# Y A H R# P I##class Solution: def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" length = len(s) if numRows == 1 or length &lt;= numRows: return s res = [] for i in range(numRows): # max_delta是打印第一行两个字符串之间的索引距离 max_delta = numRows * 2 - 2 j = i res.append(s[j]) # next_must为当前打印行和第一行竖直对应的元素索引 next_must = j + max_delta # next_cur为为斜坡元素 next_cur = next_must - 2 * i while next_cur &lt; length: if next_cur != j and next_cur != next_must: res.append(s[next_cur]) if next_must &lt; length: res.append(s[next_must]) j = next_must next_must = j + max_delta next_cur = next_must - i * 2 return ''.join(res)# if __name__ == \"__main__\":# s = 'PAYPALISHIRING'# ex = Solution()# print(ex.convert(s, 4)) LeetCode 8: String to Integer (atoi)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130## [8] String to Integer (atoi)## https://leetcode.com/problems/string-to-integer-atoi/description/## algorithms# Medium (14.14%)# Total Accepted: 270K# Total Submissions: 1.9M# Testcase Example: '\"42\"'## Implement atoi which converts a string to an integer.## The function first discards as many whitespace characters as necessary until# the first non-whitespace character is found. Then, starting from this# character, takes an optional initial plus or minus sign followed by as many# numerical digits as possible, and interprets them as a numerical value.## The string can contain additional characters after those that form the# integral number, which are ignored and have no effect on the behavior of this# function.## If the first sequence of non-whitespace characters in str is not a valid# integral number, or if no such sequence exists because either str is empty or# it contains only whitespace characters, no conversion is performed.## If no valid conversion could be performed, a zero value is returned.## Note:### Only the space character ' ' is considered as whitespace character.# Assume we are dealing with an environment which could only store integers# within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical# value is out of the range of representable values, INT_MAX (231 − 1) or# INT_MIN (−231) is returned.### Example 1:### Input: \"42\"# Output: 42### Example 2:### Input: \" -42\"# Output: -42# Explanation: The first non-whitespace character is '-', which is the minus# sign.# Then take as many numerical digits as possible, which gets 42.### Example 3:### Input: \"4193 with words\"# Output: 4193# Explanation: Conversion stops at digit '3' as the next character is not a# numerical digit.### Example 4:### Input: \"words and 987\"# Output: 0# Explanation: The first non-whitespace character is 'w', which is not a# numerical# digit or a +/- sign. Therefore no valid conversion could be performed.## Example 5:### Input: \"-91283472332\"# Output: -2147483648# Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed# integer.# Thefore INT_MIN (−231) is returned.##class Solution: def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" string = str.strip() if not string: return 0 elif string[0] not in '+-' and not self.is_num(string[0]): return 0 elif string in '+-': return 0 elif string[0] in '+-' and not self.is_num(string[1]): return 0 flag = True for i in range(1, len(string)): if not self.is_num(string[i]): flag = False break if flag: convert_string = string else: convert_string = string[:i] res = int(convert_string) if res &gt; 2 ** 31 - 1: return 2 ** 31 - 1 elif res &lt; -(2 ** 31): return -2 ** 31 else: return res def is_num(self, char): ord_val = ord(char) if ord_val &gt; 47 and ord_val &lt; 58: return True else: return False# if __name__ == \"__main__\":# string = '43'# ex = Solution()# print(ex.myAtoi(string)) LeetCode 10: Regular Expression Matching [hard]这个题是剑指offer原题，在解剑指offer中，使用的解法是暴力递归，这个解法在leetcode是通不过的，同时看了LeetCode上的Solution之后，我真的有点儿方了。上面的Python解法写的无比精炼，简直是优美，下面上一下同样的暴力递归思路的比较： 12345678910111213141516171819202122232425262728293031323334353637class Solution: # s, pattern都是字符串 def match(self, s, pattern): if len(s) == 0 and len(pattern) == 0: return True # 如果s长度不为0，而pattern长度为0，这种情况不可能匹配成功 elif len(s) != 0 and len(pattern) == 0: return False # 如果s长度为0， 而pattern长度不为0，那么可能会有pattern为'（.*）*'的情况 elif len(s) == 0 and len(pattern) != 0: # 如果pattern第二位为0, pattern推进两个 if len(pattern) &gt; 1 and pattern[1] == '*': return self.match(s, pattern[2:]) else: return False # 如果s和pattern长度都不为0 else: # pattern第二位为* if len(pattern) &gt; 1 and pattern[1] == '*': # 如果s[0] != pattern[0] if s[0] != pattern[0] and pattern[0] != '.': return self.match(s, pattern[2:]) # 如果s[0] == pattern[0], 那么有三种情况 # 1. s不变，pattern后移两步（pattern前两个字符等价于空） # 2. s右移一个， pattern右移两个 （pattern前两个字符等价于一个字符） # 3. s右移一个， pattern不右移 （pattern前两个字符等价于多个字符)） else: return self.match(s, pattern[2:]) or \\ self.match(s[1:], pattern[2:]) or \\ self.match(s[1:], pattern) # pattern第二位不是* else: # 比较第一位的情况 if s[0] == pattern[0] or pattern[0] == '.': return self.match(s[1:], pattern[1:]) else: return False LeetCode示范解法： 123456789101112class Solution(object): def isMatch(self, text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in {text[0], '.'} if len(pattern) &gt;= 2 and pattern[1] == '*': return (self.isMatch(text, pattern[2:]) or first_match and self.isMatch(text[1:], pattern)) else: return first_match and self.isMatch(text[1:], pattern[1:]) 加一点对于LeetCode标准解的解释： 首先如果是匹配pattern中没有*字符，那么匹配过程就可以简化成：1234def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in {text[0], '.'} return first_match and match(text[1:], pattern[1:]) 对应于解法中的else情况，那么如果匹配pattern中有*字符，且是解法中的if情况，那么不管pattern[0]是否匹配，我们都需要看*代表前面字符出现0次时候的情况；另外，如果第一个字符是匹配的，那么我们还要看*匹配1次或多次的情况。 暴力递归的解法是通不过LeetCode测试的，此时为了加快速度我们可以用functools里的lru_cache来保存暴力递归中间值；同样也可以把暴力递归版本改成动态规划版本，相对来说使用lru__cache更省力。 使用lru__cache只需加入两行代码，代码就不贴了。 动态规划版本:1234567891011121314class Solution(object): def isMatch(self, text, pattern): dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)] dp[-1][-1] = True for i in range(len(text), -1, -1): for j in range(len(pattern) - 1, -1, -1): first_match = i &lt; len(text) and pattern[j] in {text[i], '.'} if j+1 &lt; len(pattern) and pattern[j+1] == '*': dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j] else: dp[i][j] = first_match and dp[i+1][j+1] return dp[0][0] LeetCode 45: Jump Game II [hard]这个题是一个hard级别的题，但感觉跟其他mid难度的题差不多。这个题是做去哪儿网笔试的时候做的，只ac了67%，后来才知道是LeetCode原题，所以就想着看看代码为什么没有ac，结果到了LeetCode就ac了。。 最开始解的时候，自己没有什么好的思路。但是在思考过程中，我发现，我们是想要每一步走的最远。那么每次我们就看下当前位置能走多远，以及当前位置可走范围内的位置最远都可以走多远；那么我们如果每次都选在当前位置能走的范围内（包括当前位置）的位置中能走的最远的那么位置，那么我们就能最快到达最后一个位置。 自己真的想出来一个题的成就感是巨大的，在后来思考的过程中，我好像玄而又玄的一类的问题都应该可以这么解。但是仔细想归纳却又说不出来。但是把一个过程不是很清晰的大过程，抽象出一个可用的规则，这种能力应该会越来越强把。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465## [45] Jump Game II## https://leetcode.com/problems/jump-game-ii/description/## algorithms# Hard (26.29%)# Total Accepted: 133.1K# Total Submissions: 504.1K# Testcase Example: '[2,3,1,1,4]'## Given an array of non-negative integers, you are initially positioned at the# first index of the array.## Each element in the array represents your maximum jump length at that# position.## Your goal is to reach the last index in the minimum number of jumps.## Example:### Input: [2,3,1,1,4]# Output: 2# Explanation: The minimum number of jumps to reach the last index is 2.# ⁠ Jump 1 step from index 0 to 1, then 3 steps to the last index.## Note:## You can assume that you can always reach the last index.##class Solution: def jump(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len(nums) if length &lt;= 1: return 0 cur = 0 steps = 0 while cur &lt; length: temp = nums[cur] if cur + temp &gt;= length-1: steps += 1 return steps else: most_access = [cur, cur+temp] for i in range(cur+1, cur+temp+1): if i + nums[i] &gt; most_access[1]: most_access = [i, i+nums[i]] cur_step = temp if most_access[0] == cur else most_access[0] - cur cur = most_access[0] steps += 1# if __name__ == \"__main__\":# nums = list(map(int, input().split()))# ex = Solution()# print(ex.jump(nums))","link":"/2018/09/18/leetcode-daily/"}],"tags":[{"name":"arch","slug":"arch","link":"/tags/arch/"},{"name":"regexp","slug":"regexp","link":"/tags/regexp/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"jupyter","slug":"jupyter","link":"/tags/jupyter/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"latex","slug":"latex","link":"/tags/latex/"},{"name":"tips","slug":"tips","link":"/tags/tips/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"fortran","slug":"fortran","link":"/tags/fortran/"},{"name":"i3wm","slug":"i3wm","link":"/tags/i3wm/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"pip","slug":"pip","link":"/tags/pip/"},{"name":"spider","slug":"spider","link":"/tags/spider/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"stackoverflow","slug":"stackoverflow","link":"/tags/stackoverflow/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"source","slug":"source","link":"/tags/source/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/读书笔记/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"剑指offer","slug":"剑指offer","link":"/tags/剑指offer/"},{"name":"pep","slug":"pep","link":"/tags/pep/"},{"name":"翻译","slug":"翻译","link":"/tags/翻译/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Tips","slug":"Tips","link":"/categories/Tips/"},{"name":"VIM","slug":"VIM","link":"/categories/VIM/"},{"name":"Coding","slug":"Coding","link":"/categories/Coding/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Patterns","slug":"Patterns","link":"/categories/Patterns/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"Jekyll","slug":"Tips/Jekyll","link":"/categories/Tips/Jekyll/"},{"name":"MySQL","slug":"读书笔记/MySQL","link":"/categories/读书笔记/MySQL/"},{"name":"Python","slug":"读书笔记/Python","link":"/categories/读书笔记/Python/"},{"name":"PEP","slug":"Python/PEP","link":"/categories/Python/PEP/"},{"name":"Python","slug":"Coding/Python","link":"/categories/Coding/Python/"}]}